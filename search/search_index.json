{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TextXtract","text":"<p>TextXtract is a professional, extensible Python package for extracting text from multiple file formats with both synchronous and asynchronous support.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>Dual Input Support: Works with file paths or raw bytes</li> <li>Sync &amp; Async APIs: Choose the right approach for your use case</li> <li>Multiple Formats: PDF, DOCX, DOC, TXT, ZIP, Markdown, RTF, HTML, CSV, JSON, XML</li> <li>Optional Dependencies: Install only what you need</li> <li>Robust Error Handling: Comprehensive exception hierarchy</li> <li>Professional Logging: Detailed debug and info level logging</li> <li>Thread-Safe: Async operations use thread pools for I/O-bound tasks</li> <li>Context Manager Support: Automatic resource cleanup</li> </ul>"},{"location":"#quick-example","title":"\ud83d\udccb Quick Example","text":""},{"location":"#synchronous-extraction","title":"Synchronous Extraction","text":"<pre><code>from textxtract import SyncTextExtractor\n\nextractor = SyncTextExtractor()\n\n# From file path\ntext = extractor.extract(\"document.pdf\")\n\n# From bytes (filename required for type detection)\nwith open(\"document.pdf\", \"rb\") as f:\n    file_bytes = f.read()\ntext = extractor.extract(file_bytes, \"document.pdf\")\n</code></pre>"},{"location":"#asynchronous-extraction","title":"Asynchronous Extraction","text":"<pre><code>from textxtract import AsyncTextExtractor\nimport asyncio\n\nasync def extract_text():\n    extractor = AsyncTextExtractor()\n\n    # From file path\n    text = await extractor.extract(\"document.pdf\")\n\n    # From bytes\n    with open(\"document.pdf\", \"rb\") as f:\n        file_bytes = f.read()\n    text = await extractor.extract(file_bytes, \"document.pdf\")\n\n    return text\n\ntext = asyncio.run(extract_text())\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Installation - Get started quickly</li> <li>Usage Guide - Comprehensive usage examples</li> <li>API Reference - Complete API documentation</li> <li>Testing - Running tests and validation</li> <li>Contributing - Help improve the project</li> <li>Changelog - Version history and updates</li> </ul>"},{"location":"#supported-file-types","title":"\ud83d\udd27 Supported File Types","text":"Format Extension Dependencies Handler Text <code>.txt</code>, <code>.text</code> Built-in stdlib Markdown <code>.md</code> <code>pip install textxtract[md]</code> markdown PDF <code>.pdf</code> <code>pip install textxtract[pdf]</code> PyMuPDF Word <code>.docx</code> <code>pip install textxtract[docx]</code> python-docx Word Legacy <code>.doc</code> <code>pip install textxtract[doc]</code> antiword Rich Text <code>.rtf</code> <code>pip install textxtract[rtf]</code> striprtf HTML <code>.html</code>, <code>.htm</code> <code>pip install textxtract[html]</code> beautifulsoup4 CSV <code>.csv</code> Built-in stdlib JSON <code>.json</code> Built-in stdlib XML <code>.xml</code> <code>pip install textxtract[xml]</code> lxml ZIP Archives <code>.zip</code> Built-in stdlib"},{"location":"#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":"<p>Text Extractor provides comprehensive error handling with custom exceptions:</p> <pre><code>from textxtract import SyncTextExtractor\nfrom textxtract.core.exceptions import (\n    FileTypeNotSupportedError,\n    InvalidFileError,\n    ExtractionError\n)\n\nextractor = SyncTextExtractor()\n\ntry:\n    text = extractor.extract(\"document.pdf\")\nexcept FileTypeNotSupportedError:\n    print(\"File type not supported\")\nexcept InvalidFileError:\n    print(\"File is corrupted or invalid\")\nexcept ExtractionError:\n    print(\"Extraction failed\")\n</code></pre>"},{"location":"#why-choose-text-extractor","title":"\ud83c\udfaf Why Choose Text Extractor?","text":"<ul> <li>Production Ready: Robust error handling and logging</li> <li>Flexible: Support for both file paths and bytes</li> <li>Performant: Async support for concurrent processing</li> <li>Lightweight: Optional dependencies keep it minimal</li> <li>Well Tested: Comprehensive test suite</li> <li>Well Documented: Clear examples and API docs</li> </ul>"},{"location":"#get-started","title":"\ud83d\ude80 Get Started","text":"<pre><code>pip install textxtract\n</code></pre> <p>Ready to extract text from your files? Check out our Installation Guide and Usage Examples.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API reference for the <code>textxtract</code> package.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#synctextextractor","title":"SyncTextExtractor","text":"<p>The synchronous text extractor for blocking operations.</p> <pre><code>from textxtract import SyncTextExtractor\n</code></pre>"},{"location":"api/#constructor","title":"Constructor","text":"<pre><code>SyncTextExtractor(config: Optional[ExtractorConfig] = None)\n</code></pre> <p>Parameters: - <code>config</code> (optional): Configuration object for customizing extraction behavior</p>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#extract","title":"extract()","text":"<pre><code>extract(\n    source: Union[Path, str, bytes], \n    filename: Optional[str] = None, \n    config: Optional[dict] = None\n) -&gt; str\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> <p>Parameters: - <code>source</code>: File path (Path/str) or file bytes - <code>filename</code>: Required if source is bytes, optional for file paths - <code>config</code>: Optional configuration overrides</p> <p>Returns: - <code>str</code>: Extracted text</p> <p>Raises: - <code>ValueError</code>: If filename is missing when source is bytes - <code>FileTypeNotSupportedError</code>: If file extension is not supported - <code>InvalidFileError</code>: If file is invalid or corrupted - <code>ExtractionError</code>: If extraction fails</p> <p>Examples:</p> <pre><code>extractor = SyncTextExtractor()\n\n# From file path\ntext = extractor.extract(\"document.pdf\")\ntext = extractor.extract(Path(\"document.pdf\"))\n\n# From bytes (filename required)\nwith open(\"document.pdf\", \"rb\") as f:\n    file_bytes = f.read()\ntext = extractor.extract(file_bytes, \"document.pdf\")\n\n# With custom config\nconfig = {\"encoding\": \"utf-8\", \"max_file_size\": 50*1024*1024}\ntext = extractor.extract(\"document.pdf\", config=config)\n</code></pre>"},{"location":"api/#context-manager-support","title":"Context Manager Support","text":"<pre><code>with SyncTextExtractor() as extractor:\n    text = extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"api/#asynctextextractor","title":"AsyncTextExtractor","text":"<p>The asynchronous text extractor for non-blocking operations.</p> <pre><code>from textxtract import AsyncTextExtractor\n</code></pre>"},{"location":"api/#constructor_1","title":"Constructor","text":"<pre><code>AsyncTextExtractor(config: Optional[ExtractorConfig] = None)\n</code></pre> <p>Parameters: - <code>config</code> (optional): Configuration object for customizing extraction behavior</p>"},{"location":"api/#methods_1","title":"Methods","text":""},{"location":"api/#extract_1","title":"extract()","text":"<pre><code>async extract(\n    source: Union[Path, str, bytes], \n    filename: Optional[str] = None, \n    config: Optional[dict] = None\n) -&gt; str\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters: - <code>source</code>: File path (Path/str) or file bytes - <code>filename</code>: Required if source is bytes, optional for file paths - <code>config</code>: Optional configuration overrides</p> <p>Returns: - <code>str</code>: Extracted text</p> <p>Raises: - <code>ValueError</code>: If filename is missing when source is bytes - <code>FileTypeNotSupportedError</code>: If file extension is not supported - <code>InvalidFileError</code>: If file is invalid or corrupted - <code>ExtractionError</code>: If extraction fails</p> <p>Examples:</p> <pre><code>import asyncio\n\nasync def extract_text():\n    extractor = AsyncTextExtractor()\n\n    # From file path\n    text = await extractor.extract(\"document.pdf\")\n\n    # From bytes\n    with open(\"document.pdf\", \"rb\") as f:\n        file_bytes = f.read()\n    text = await extractor.extract(file_bytes, \"document.pdf\")\n\n    return text\n\ntext = asyncio.run(extract_text())\n</code></pre>"},{"location":"api/#context-manager-support_1","title":"Context Manager Support","text":"<pre><code>async with AsyncTextExtractor() as extractor:\n    text = await extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#extractorconfig","title":"ExtractorConfig","text":"<p>Configuration class for customizing extraction behavior.</p> <pre><code>from textxtract.core import ExtractorConfig\n</code></pre>"},{"location":"api/#constructor_2","title":"Constructor","text":"<pre><code>ExtractorConfig(\n    encoding: str = \"utf-8\",\n    max_file_size: int = 100 * 1024 * 1024,  # 100MB\n    logging_level: str = \"INFO\"\n)\n</code></pre> <p>Parameters: - <code>encoding</code>: Default text encoding - <code>max_file_size</code>: Maximum file size in bytes - <code>logging_level</code>: Logging verbosity level</p> <p>Example:</p> <pre><code>config = ExtractorConfig(\n    encoding=\"utf-8\",\n    max_file_size=50 * 1024 * 1024,  # 50MB\n    logging_level=\"DEBUG\"\n)\n\nextractor = SyncTextExtractor(config)\n</code></pre>"},{"location":"api/#exceptions","title":"Exceptions","text":"<p>All exceptions are in the <code>textxtract.core.exceptions</code> module.</p>"},{"location":"api/#extractionerror","title":"ExtractionError","text":"<p>Base exception for all extraction-related errors.</p> <pre><code>from textxtract.core.exceptions import ExtractionError\n</code></pre>"},{"location":"api/#filetypenotsupportederror","title":"FileTypeNotSupportedError","text":"<p>Raised when the file extension is not supported.</p> <pre><code>from textxtract.core.exceptions import FileTypeNotSupportedError\n</code></pre>"},{"location":"api/#invalidfileerror","title":"InvalidFileError","text":"<p>Raised when the file is invalid, corrupted, or not found.</p> <pre><code>from textxtract.core.exceptions import InvalidFileError\n</code></pre>"},{"location":"api/#extractiontimeouterror","title":"ExtractionTimeoutError","text":"<p>Raised when extraction exceeds the allowed timeout.</p> <pre><code>from textxtract.core.exceptions import ExtractionTimeoutError\n</code></pre> <p>Example Error Handling:</p> <pre><code>from textxtract import SyncTextExtractor\nfrom textxtract.core.exceptions import (\n    ExtractionError,\n    FileTypeNotSupportedError,\n    InvalidFileError\n)\n\nextractor = SyncTextExtractor()\n\ntry:\n    text = extractor.extract(\"document.pdf\")\nexcept FileTypeNotSupportedError as e:\n    print(f\"Unsupported file type: {e}\")\nexcept InvalidFileError as e:\n    print(f\"Invalid file: {e}\")\nexcept ExtractionError as e:\n    print(f\"Extraction failed: {e}\")\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#fileinfo","title":"FileInfo","text":"<p>Data class containing file information.</p> <pre><code>from textxtract.core.utils import FileInfo\n</code></pre>"},{"location":"api/#attributes","title":"Attributes","text":"<ul> <li><code>filename</code>: str - Name of the file</li> <li><code>size_bytes</code>: int - File size in bytes</li> <li><code>size_mb</code>: float - File size in megabytes</li> <li><code>size_kb</code>: float - File size in kilobytes (property)</li> <li><code>extension</code>: str - File extension</li> <li><code>is_temp</code>: bool - Whether file is temporary</li> </ul>"},{"location":"api/#supported-file-types","title":"Supported File Types","text":"Extension Handler Class Optional Dependency <code>.txt</code>, <code>.text</code> <code>TXTHandler</code> None <code>.pdf</code> <code>PDFHandler</code> <code>pymupdf</code> <code>.docx</code> <code>DOCXHandler</code> <code>python-docx</code> <code>.doc</code> <code>DOCHandler</code> <code>antiword</code> <code>.md</code> <code>MDHandler</code> <code>markdown</code>, <code>beautifulsoup4</code> <code>.rtf</code> <code>RTFHandler</code> <code>striprtf</code> <code>.html</code>, <code>.htm</code> <code>HTMLHandler</code> <code>beautifulsoup4</code>, <code>lxml</code> <code>.csv</code> <code>CSVHandler</code> None <code>.json</code> <code>JSONHandler</code> None <code>.xml</code> <code>XMLHandler</code> <code>lxml</code> <code>.zip</code> <code>ZIPHandler</code> None"},{"location":"api/#logging","title":"Logging","text":"<p>The package uses Python's standard logging module with the following loggers:</p> <ul> <li><code>textxtract.sync</code> - Synchronous extractor logs</li> <li><code>textxtract.aio</code> - Asynchronous extractor logs</li> <li><code>textxtract.utils</code> - Utility function logs</li> </ul> <p>Configure logging:</p> <pre><code>import logging\n\n# Set debug level for detailed logs\nlogging.basicConfig(level=logging.DEBUG)\n\n# Or configure specific logger\nlogger = logging.getLogger(\"textxtract\")\nlogger.setLevel(logging.INFO)\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>The package is fully typed. Import types for better IDE support:</p> <p>```python from typing import Union, Optional from pathlib import Path from textxtract import SyncTextExtractor, AsyncTextExtractor from textxtract.core import ExtractorConfig from textxtract.core.exceptions import ExtractionError</p>"},{"location":"architecture/","title":"TextXtract Package: Architectural Plan","text":""},{"location":"architecture/#mermaid-diagram-high-level-architecture","title":"Mermaid Diagram: High-Level Architecture","text":"<pre><code>classDiagram\n    class TextXtract {\n        +extract()\n        +extract_async()\n    }\n    class FileTypeHandler {\n        +extract(file_path, config)\n    }\n    TextExtractor &lt;|-- SyncTextExtractor\n    TextExtractor &lt;|-- AsyncTextExtractor\n    FileTypeHandler &lt;|-- PDFHandler\n    FileTypeHandler &lt;|-- DOCXHandler\n    FileTypeHandler &lt;|-- DOCHandler\n    FileTypeHandler &lt;|-- TXTHandler\n    FileTypeHandler &lt;|-- ZIPHandler\n    FileTypeHandler &lt;|-- RTFHandler\n    FileTypeHandler &lt;|-- HTMLHandler\n    FileTypeHandler &lt;|-- MDHandler\n    FileTypeHandler &lt;|-- CSVHandler\n    FileTypeHandler &lt;|-- JSONHandler\n    FileTypeHandler &lt;|-- XMLHandler\n    SyncTextExtractor o-- FileTypeHandler\n    AsyncTextExtractor o-- FileTypeHandler\n    SyncTextExtractor o-- Registry\n    AsyncTextExtractor o-- Registry\n    Registry o-- FileTypeHandler</code></pre>"},{"location":"architecture/#key-features","title":"Key Features","text":"<ul> <li>Extensible: Add new file handlers by subclassing <code>FileTypeHandler</code> and registering.</li> <li>Sync &amp; Async: Both interfaces, async is truly non-blocking.</li> <li>Robust: Comprehensive error handling, logging, and resource management.</li> <li>Configurable: Encoding, logging, handler registration, timeouts, per-handler config.</li> <li>Testable: Pytest-based tests for all components, including edge cases.</li> <li>Scalable: Lazy loading, caching, parallel processing (future-proofed).</li> <li>Secure: Input validation, safe file handling, ZIP traversal protection.</li> </ul>"},{"location":"architecture/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Scaffold the directory and file structure.</li> <li>Implement core abstractions and utilities.</li> <li>Implement file type handlers.</li> <li>Implement sync and async extractors.</li> <li>Add configuration, logging, and error handling.</li> <li>Write comprehensive tests (unit, async, edge cases).</li> <li>Document usage and API (auto-generated docs).</li> <li>Finalize dependencies and code quality checks.</li> </ol>"},{"location":"architecture/#api-reference","title":"API Reference","text":"<p>Checkout the main API Reference for detailed documentation on each class and method.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to the <code>textxtract</code> project are documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#020","title":"[0.2.0]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for both file paths and bytes input in extractors</li> <li>Enhanced <code>FileInfo</code> dataclass with comprehensive file metadata</li> <li>Context manager support for both sync and async extractors</li> <li>Improved logging with structured file information</li> <li>Thread pool optimization for async operations</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Unified API: both extractors use <code>extract()</code> method name</li> <li>Enhanced error handling with custom exception hierarchy</li> <li>Improved documentation with professional styling</li> <li>Better test coverage for all input methods</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Memory leaks in async operations</li> <li>Temporary file cleanup issues</li> <li>Type hint improvements</li> </ul> <p>For detailed information about any release, see the API Documentation and Usage Guide.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to textxtract! We welcome contributions of all kinds, from bug reports to new features.</p>"},{"location":"contributing/#quick-start-for-contributors","title":"\ud83d\ude80 Quick Start for Contributors","text":""},{"location":"contributing/#1-development-setup","title":"1. Development Setup","text":"<pre><code># Fork and clone the repository\ngit clone https://github.com/10XScale-in/textxtract.git\ncd textxtract\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode with all dependencies\npip install -e .[all]\n\n# Install development tools\npip install pytest pytest-asyncio pytest-cov black isort mypy pre-commit\n</code></pre>"},{"location":"contributing/#2-development-workflow","title":"2. Development Workflow","text":"<pre><code># Create a feature branch\ngit checkout -b feature/your-feature-name\n\n# Make your changes\n# ... edit code ...\n\n# Run tests\npytest\n\n# Format code\nblack textxtract tests\nisort textxtract tests\n\n# Type check\nmypy textxtract\n\n# Commit your changes\ngit add .\ngit commit -m \"feat: add your feature description\"\n\n# Push and create PR\ngit push origin feature/your-feature-name\n</code></pre>"},{"location":"contributing/#contribution-guidelines","title":"\ud83d\udccb Contribution Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow these conventions:</p> <ul> <li>PEP 8 for Python code style</li> <li>Black for code formatting</li> <li>isort for import sorting</li> <li>Type hints for all public APIs</li> <li>Docstrings for all public functions and classes</li> </ul>"},{"location":"contributing/#code-formatting","title":"Code Formatting","text":"<pre><code># Format code with black\nblack textxtract tests\n\n# Sort imports\nisort textxtract tests\n\n# Check formatting\nblack --check textxtract tests\nisort --check textxtract tests\n</code></pre>"},{"location":"contributing/#type-checking","title":"Type Checking","text":"<pre><code># Run type checking\nmypy textxtract\n\n# Check specific file\nmypy textxtract/sync/extractor.py\n</code></pre>"},{"location":"contributing/#testing-requirements","title":"\ud83e\uddea Testing Requirements","text":""},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<p>All contributions must include appropriate tests:</p> <pre><code># Example test structure\nimport pytest\nfrom pathlib import Path\nfrom textxtract import SyncTextExtractor\nfrom textxtract.exceptions import FileTypeNotSupportedError\n\ndef test_new_feature():\n    \"\"\"Test description of the new feature.\"\"\"\n    extractor = SyncTextExtractor()\n\n    # Test successful case\n    result = extractor.extract(\"test_file.txt\")\n    assert isinstance(result, str)\n    assert len(result) &gt; 0\n\n    # Test error case\n    with pytest.raises(FileTypeNotSupportedError):\n        extractor.extract(b\"dummy\", \"file.unsupported\")\n\n@pytest.mark.asyncio\nasync def test_async_feature():\n    \"\"\"Test async functionality.\"\"\"\n    from textxtract import AsyncTextExtractor\n\n    extractor = AsyncTextExtractor()\n    result = await extractor.extract(\"test_file.txt\")\n    assert isinstance(result, str)\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=textxtract --cov-report=html\n\n# Run specific test categories\npytest tests/test_sync.py\npytest tests/test_async.py\n\n# Run performance tests\npytest -m slow\n</code></pre>"},{"location":"contributing/#test-coverage-requirements","title":"Test Coverage Requirements","text":"<ul> <li>All new code must have 90%+ test coverage</li> <li>Both sync and async paths must be tested</li> <li>Error conditions must be tested</li> <li>Integration tests for new file types</li> </ul>"},{"location":"contributing/#adding-new-file-type-support","title":"\ud83c\udfd7\ufe0f Adding New File Type Support","text":""},{"location":"contributing/#1-create-handler-class","title":"1. Create Handler Class","text":"<pre><code># textxtract/handlers/your_format.py\n\"\"\"Handler for YOUR_FORMAT files.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Optional\nfrom textxtract.core.base import FileTypeHandler\nfrom textxtract.exceptions import ExtractionError\n\nclass YourFormatHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from YOUR_FORMAT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            # Check for required dependency\n            try:\n                import your_library\n            except ImportError:\n                raise ExtractionError(\n                    \"your_library is not installed. \"\n                    \"Install with 'pip install textxtract[your_format]'\"\n                )\n\n            # Extract text logic\n            with open(file_path, 'rb') as f:\n                content = your_library.extract_text(f)\n\n            return content\n\n        except Exception as e:\n            raise ExtractionError(f\"YOUR_FORMAT extraction failed: {e}\")\n\n    async def extract_async(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        import asyncio\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"contributing/#2-register-handler","title":"2. Register Handler","text":"<p>Add to the registry in <code>textxtract/core/registry.py</code>:</p> <pre><code>from textxtract.handlers.your_format import YourFormatHandler\n\n# Add to handler map\nHANDLER_MAP = {\n    # ... existing handlers ...\n    \".your_ext\": YourFormatHandler,\n}\n</code></pre>"},{"location":"contributing/#3-update-dependencies","title":"3. Update Dependencies","text":"<p>Add to <code>pyproject.toml</code>:</p> <pre><code>[project.optional-dependencies]\nyour_format = [\"your_library&gt;=1.0.0\"]\nall = [\n    # ... existing dependencies ...\n    \"your_library&gt;=1.0.0\",\n]\n</code></pre>"},{"location":"contributing/#4-add-tests","title":"4. Add Tests","text":"<p>Create test files and test cases:</p> <pre><code># tests/test_your_format.py\nimport pytest\nfrom pathlib import Path\nfrom textxtract import SyncTextExtractor, AsyncTextExtractor\n\nTEST_FILES_DIR = Path(__file__).parent / \"files\"\n\ndef test_your_format_sync():\n    extractor = SyncTextExtractor()\n    text = extractor.extract(TEST_FILES_DIR / \"test_file.your_ext\")\n    assert isinstance(text, str)\n    assert len(text) &gt; 0\n\n@pytest.mark.asyncio\nasync def test_your_format_async():\n    extractor = AsyncTextExtractor()\n    text = await extractor.extract(TEST_FILES_DIR / \"test_file.your_ext\")\n    assert isinstance(text, str)\n    assert len(text) &gt; 0\n</code></pre>"},{"location":"contributing/#5-update-documentation","title":"5. Update Documentation","text":"<p>Update the following files: - <code>docs/usage.md</code> - Add your format to supported types table - <code>docs/installation.md</code> - Add installation instructions - <code>docs/api.md</code> - Document the new handler</p>"},{"location":"contributing/#bug-reports","title":"\ud83d\udc1b Bug Reports","text":""},{"location":"contributing/#before-reporting","title":"Before Reporting","text":"<ol> <li>Check existing issues</li> <li>Verify with latest version</li> <li>Create minimal reproduction case</li> </ol>"},{"location":"contributing/#bug-report-template","title":"Bug Report Template","text":"<pre><code>**Bug Description**\nClear description of the bug.\n\n**Steps to Reproduce**\n1. Step one\n2. Step two\n3. ...\n\n**Expected Behavior**\nWhat should happen.\n\n**Actual Behavior**\nWhat actually happens.\n\n**Environment**\n- OS: [e.g., Ubuntu 20.04]\n- Python: [e.g., 3.9.7]\n- textxtract: [e.g., 0.2.0]\n- Dependencies: [relevant package versions]\n\n**Code Sample**\n```python\nfrom textxtract import SyncTextExtractor\n\nextractor = SyncTextExtractor()\n# Code that reproduces the issue\n</code></pre> <p>Error Messages <pre><code>Full error traceback\n</code></pre> <pre><code>## \ud83d\udca1 Feature Requests\n\n### Feature Request Template\n\n```markdown\n**Feature Description**\nClear description of the proposed feature.\n\n**Use Case**\nWhy is this feature needed? What problem does it solve?\n\n**Proposed API**\n```python\n# Example of how the feature would be used\n</code></pre></p> <p>Alternatives Considered Other approaches you've considered.</p> <p>Additional Context Any other relevant information. <pre><code>## \ud83d\udcdd Documentation Contributions\n\n### Documentation Structure\n</code></pre> docs/ \u251c\u2500\u2500 index.md           # Main landing page \u251c\u2500\u2500 installation.md    # Installation guide \u251c\u2500\u2500 usage.md          # Usage examples \u251c\u2500\u2500 api.md            # API reference \u251c\u2500\u2500 testing.md        # Testing guide \u251c\u2500\u2500 contributing.md   # This file \u2514\u2500\u2500 changelog.md      # Version history <pre><code>### Writing Guidelines\n\n- Use clear, concise language\n- Include working code examples\n- Test all code examples\n- Use consistent formatting\n- Add cross-references between sections\n\n### Building Documentation\n\n```bash\n# Install MkDocs\npip install mkdocs mkdocs-material\n\n# Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre></p>"},{"location":"contributing/#release-process","title":"\ud83d\udd04 Release Process","text":""},{"location":"contributing/#versioning","title":"Versioning","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"contributing/#release-checklist","title":"Release Checklist","text":"<ul> <li>[ ] Update version in <code>pyproject.toml</code></li> <li>[ ] Update <code>CHANGELOG.md</code></li> <li>[ ] Run full test suite</li> <li>[ ] Update documentation</li> <li>[ ] Create release PR</li> <li>[ ] Tag release after merge</li> <li>[ ] Publish to PyPI</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"\ud83e\udd1d Code of Conduct","text":""},{"location":"contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Provide constructive feedback</li> <li>Focus on what's best for the community</li> <li>Show empathy towards other contributors</li> </ul>"},{"location":"contributing/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>Harassment or discrimination</li> <li>Trolling or insulting comments</li> <li>Publishing private information</li> <li>Unprofessional conduct</li> </ul> <p>Thank you for helping make textxtract better! \ud83c\udf89</p>"},{"location":"installation/","title":"Installation","text":"<p>Text Extractor is designed to be lightweight and modular, allowing you to install only the dependencies you need for your specific use case.</p>"},{"location":"installation/#basic-installation","title":"\ud83d\udce6 Basic Installation","text":"<p>Install the core package without optional dependencies:</p> <pre><code>pip install textxtract\n</code></pre> <p>This provides basic text extraction for: - <code>.txt</code> and <code>.text</code> files - <code>.csv</code> files - <code>.json</code> files - <code>.zip</code> archives</p>"},{"location":"installation/#install-with-file-type-support","title":"\ud83c\udfaf Install with File Type Support","text":"<p>Install support for specific file types using optional extras:</p>"},{"location":"installation/#individual-file-types","title":"Individual File Types","text":"<pre><code># PDF support\npip install textxtract[pdf]\n\n# Microsoft Word (.docx) support\npip install textxtract[docx]\n\n# Legacy Word (.doc) support\npip install textxtract[doc]\n\n# Markdown support\npip install textxtract[md]\n\n# Rich Text Format support\npip install textxtract[rtf]\n\n# HTML support\npip install textxtract[html]\n\n# XML support\npip install textxtract[xml]\n</code></pre>"},{"location":"installation/#multiple-file-types","title":"Multiple File Types","text":"<pre><code># Install support for multiple formats\npip install textxtract[pdf,docx,html]\n\n# Install all supported formats\npip install textxtract[all]\n</code></pre>"},{"location":"installation/#available-extras","title":"\ud83d\udd27 Available Extras","text":"Extra Dependencies File Types Supported <code>pdf</code> <code>pymupdf</code> <code>.pdf</code> <code>docx</code> <code>python-docx</code> <code>.docx</code> <code>doc</code> <code>antiword</code> <code>.doc</code> <code>md</code> <code>markdown</code>, <code>beautifulsoup4</code> <code>.md</code> <code>rtf</code> <code>striprtf</code> <code>.rtf</code> <code>html</code> <code>beautifulsoup4</code>, <code>lxml</code> <code>.html</code>, <code>.htm</code> <code>xml</code> <code>lxml</code> <code>.xml</code> <code>all</code> All of the above All supported types"},{"location":"installation/#python-version-requirements","title":"\ud83d\udc0d Python Version Requirements","text":"<ul> <li>Python 3.9 or higher is required</li> <li>Tested on Python 3.9, 3.10, 3.11, 3.12, and 3.13</li> </ul>"},{"location":"installation/#upgrading","title":"\ud83d\udd04 Upgrading","text":"<p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade textxtract\n</code></pre> <p>To upgrade with all extras:</p> <pre><code>pip install --upgrade textxtract[all]\n</code></pre>"},{"location":"installation/#development-installation","title":"\ud83d\ude80 Development Installation","text":"<p>For development or contributing:</p> <pre><code># Clone the repository\ngit clone https://github.com/your-org/text-extractor.git\ncd text-extractor\n\n# Install in development mode with all dependencies\npip install -e .[all]\n\n# Install development dependencies\npip install pytest pytest-asyncio\n</code></pre>"},{"location":"installation/#system-requirements","title":"\ud83d\udccb System Requirements","text":""},{"location":"installation/#for-doc-files-antiword","title":"For <code>.doc</code> files (antiword)","text":"<p>On Ubuntu/Debian: <pre><code>sudo apt-get install antiword\n</code></pre></p> <p>On macOS: <pre><code>brew install antiword\n</code></pre></p> <p>On Windows: Download antiword from the official website and ensure it's in your PATH.</p>"},{"location":"installation/#verify-installation","title":"\u2705 Verify Installation","text":"<p>Test your installation:</p> <pre><code>from textxtract import SyncTextExtractor\n\nextractor = SyncTextExtractor()\nprint(\"Installation successful!\")\n</code></pre>"},{"location":"installation/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":"<p>Import Error: Make sure you have the correct package name: <pre><code># Correct\nfrom textxtract import SyncTextExtractor\n\n# Incorrect\nfrom text_extractor import SyncTextExtractor\n</code></pre></p> <p>Missing Dependencies: Install the required extras for your file types: <pre><code>pip install textxtract[pdf]  # For PDF support\n</code></pre></p> <p>Permission Errors: On some systems, you may need to install with user permissions: <pre><code>pip install --user textxtract\n</code></pre></p>"},{"location":"installation/#getting-help","title":"\ud83c\udd98 Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the Usage Guide for examples</li> <li>Review the API Documentation</li> <li>Look at the Testing Guide for validation</li> <li>Open an issue on our GitHub repository</li> </ol>"},{"location":"testing/","title":"Testing","text":"<p>Comprehensive testing guide for the <code>textxtract</code> package.</p>"},{"location":"testing/#running-tests","title":"\ud83e\uddea Running Tests","text":"<p>The project uses pytest for all tests with support for both synchronous and asynchronous testing.</p>"},{"location":"testing/#prerequisites","title":"Prerequisites","text":"<p>Install the package with all optional dependencies for complete testing:</p> <pre><code>pip install textxtract[all]\npip install pytest pytest-asyncio\n</code></pre>"},{"location":"testing/#basic-test-execution","title":"Basic Test Execution","text":"<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Run specific test file\npytest tests/test_sync.py\npytest tests/test_async.py\n\n# Run tests with coverage\npytest --cov=textxtract\n</code></pre>"},{"location":"testing/#test-categories","title":"Test Categories","text":"<pre><code># Run only synchronous tests\npytest tests/test_sync.py\n\n# Run only asynchronous tests  \npytest tests/test_async.py\n\n# Run exception handling tests\npytest tests/test_exceptions.py\n\n# Run edge case tests\npytest tests/test_edge_cases.py\n</code></pre>"},{"location":"testing/#test-structure","title":"\ud83d\udcc2 Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 test_sync.py          # Synchronous extractor tests\n\u251c\u2500\u2500 test_async.py         # Asynchronous extractor tests\n\u251c\u2500\u2500 test_exceptions.py    # Error handling tests\n\u251c\u2500\u2500 test_edge_cases.py    # Edge cases and validation\n\u2514\u2500\u2500 files/               # Sample test files\n    \u251c\u2500\u2500 text_file.txt\n    \u251c\u2500\u2500 text_file.pdf\n    \u251c\u2500\u2500 text_file.docx\n    \u251c\u2500\u2500 markdown.md\n    \u251c\u2500\u2500 text.csv\n    \u251c\u2500\u2500 text.json\n    \u251c\u2500\u2500 text.html\n    \u251c\u2500\u2500 text.xml\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"testing/#test-coverage","title":"\ud83d\udd27 Test Coverage","text":""},{"location":"testing/#file-type-coverage","title":"File Type Coverage","text":"<p>The test suite covers all supported file types:</p> File Type Test Files Sync Tests Async Tests Plain Text <code>text_file.txt</code>, <code>text_file.text</code> \u2705 \u2705 Markdown <code>markdown.md</code> \u2705 \u2705 PDF <code>text_file.pdf</code> \u2705 \u2705 Word <code>text_file.docx</code> \u2705 \u2705 Legacy Word <code>text_file.doc</code> \u2705 \u2705 Rich Text <code>text_file.rtf</code> \u2705 \u2705 HTML <code>text.html</code> \u2705 \u2705 CSV <code>text.csv</code> \u2705 \u2705 JSON <code>text.json</code> \u2705 \u2705 XML <code>text.xml</code> \u2705 \u2705 ZIP <code>text_zip.zip</code> \u2705 \u2705"},{"location":"testing/#input-method-coverage","title":"Input Method Coverage","text":"<ul> <li>\u2705 File path extraction (<code>extractor.extract(\"/path/to/file.pdf\")</code>)</li> <li>\u2705 Bytes extraction (<code>extractor.extract(file_bytes, \"file.pdf\")</code>)</li> <li>\u2705 Both sync and async methods</li> <li>\u2705 Error handling for unsupported types</li> <li>\u2705 Context manager usage</li> </ul>"},{"location":"testing/#error-handling-coverage","title":"Error Handling Coverage","text":"<ul> <li>\u2705 <code>FileTypeNotSupportedError</code> for unsupported extensions</li> <li>\u2705 <code>InvalidFileError</code> for corrupted/missing files</li> <li>\u2705 <code>ExtractionError</code> for extraction failures</li> <li>\u2705 <code>ValueError</code> for missing filename with bytes input</li> </ul>"},{"location":"testing/#writing-custom-tests","title":"\ud83c\udfaf Writing Custom Tests","text":""},{"location":"testing/#testing-file-extraction","title":"Testing File Extraction","text":"<pre><code>import pytest\nfrom pathlib import Path\nfrom textxtract import SyncTextExtractor\nfrom textxtract.core.exceptions import FileTypeNotSupportedError\n\ndef test_custom_file_extraction():\n    extractor = SyncTextExtractor()\n\n    # Test with file path\n    text = extractor.extract(\"path/to/test/file.txt\")\n    assert isinstance(text, str)\n    assert len(text) &gt; 0\n\n    # Test with bytes\n    with open(\"path/to/test/file.txt\", \"rb\") as f:\n        file_bytes = f.read()\n    text = extractor.extract(file_bytes, \"file.txt\")\n    assert isinstance(text, str)\n    assert len(text) &gt; 0\n</code></pre>"},{"location":"testing/#testing-async-extraction","title":"Testing Async Extraction","text":"<pre><code>import pytest\nfrom textxtract import AsyncTextExtractor\n\n@pytest.mark.asyncio\nasync def test_async_extraction():\n    extractor = AsyncTextExtractor()\n\n    text = await extractor.extract(\"path/to/test/file.txt\")\n    assert isinstance(text, str)\n    assert len(text) &gt; 0\n</code></pre>"},{"location":"testing/#testing-error-conditions","title":"Testing Error Conditions","text":"<pre><code>import pytest\nfrom textxtract import SyncTextExtractor\nfrom textxtract.core.exceptions import (\n    FileTypeNotSupportedError,\n    InvalidFileError\n)\n\ndef test_error_handling():\n    extractor = SyncTextExtractor()\n\n    # Test unsupported file type\n    with pytest.raises(FileTypeNotSupportedError):\n        extractor.extract(b\"dummy\", \"file.unsupported\")\n\n    # Test missing file\n    with pytest.raises(InvalidFileError):\n        extractor.extract(\"nonexistent_file.txt\")\n\n    # Test missing filename with bytes\n    with pytest.raises(ValueError):\n        extractor.extract(b\"dummy bytes\")\n</code></pre>"},{"location":"testing/#performance-testing","title":"\ud83d\ude80 Performance Testing","text":""},{"location":"testing/#memory-usage-testing","title":"Memory Usage Testing","text":"<pre><code>import psutil\nimport os\nfrom textxtract import SyncTextExtractor\n\ndef test_memory_usage():\n    process = psutil.Process(os.getpid())\n    initial_memory = process.memory_info().rss\n\n    extractor = SyncTextExtractor()\n\n    # Process large file\n    text = extractor.extract(\"large_file.pdf\")\n\n    final_memory = process.memory_info().rss\n    memory_increase = final_memory - initial_memory\n\n    # Assert reasonable memory usage\n    assert memory_increase &lt; 100 * 1024 * 1024  # Less than 100MB\n</code></pre>"},{"location":"testing/#concurrent-processing-testing","title":"Concurrent Processing Testing","text":"<pre><code>import asyncio\nimport pytest\nfrom textxtract import AsyncTextExtractor\n\n@pytest.mark.asyncio\nasync def test_concurrent_extraction():\n    extractor = AsyncTextExtractor()\n\n    files = [\"file1.txt\", \"file2.pdf\", \"file3.docx\"]\n\n    # Process files concurrently\n    tasks = [extractor.extract(file) for file in files]\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n\n    # Verify all succeeded\n    for result in results:\n        assert isinstance(result, str)\n        assert len(result) &gt; 0\n</code></pre>"},{"location":"testing/#test-configuration","title":"\ud83d\udd0d Test Configuration","text":""},{"location":"testing/#pytestini-configuration","title":"pytest.ini Configuration","text":"<pre><code>[tool:pytest]\nminversion = 6.0\naddopts = -ra -q --tb=short\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\nmarkers =\n    slow: marks tests as slow (deselect with '-m \"not slow\"')\n    integration: marks tests as integration tests\n</code></pre>"},{"location":"testing/#running-specific-test-categories","title":"Running Specific Test Categories","text":"<pre><code># Run only fast tests\npytest -m \"not slow\"\n\n# Run only integration tests\npytest -m integration\n\n# Run tests with specific keyword\npytest -k \"test_sync\"\n\n# Run tests and stop on first failure\npytest -x\n</code></pre>"},{"location":"testing/#debugging-tests","title":"\ud83d\udc1b Debugging Tests","text":""},{"location":"testing/#verbose-output","title":"Verbose Output","text":"<pre><code># Maximum verbosity\npytest -vvv\n\n# Show local variables in tracebacks\npytest --tb=long\n\n# Show stdout/stderr\npytest -s\n</code></pre>"},{"location":"testing/#debugging-with-pdb","title":"Debugging with pdb","text":"<pre><code>import pytest\n\ndef test_with_debugger():\n    extractor = SyncTextExtractor()\n\n    # Set breakpoint\n    pytest.set_trace()\n\n    text = extractor.extract(\"test_file.txt\")\n    assert text\n</code></pre>"},{"location":"testing/#test-reports","title":"\ud83d\udcca Test Reports","text":""},{"location":"testing/#coverage-reports","title":"Coverage Reports","text":"<pre><code># Generate coverage report\npytest --cov=textxtract --cov-report=html\n\n# View coverage in terminal\npytest --cov=textxtract --cov-report=term-missing\n\n# Generate XML coverage for CI\npytest --cov=textxtract --cov-report=xml\n</code></pre>"},{"location":"testing/#junit-xml-reports","title":"JUnit XML Reports","text":"<pre><code># Generate JUnit XML for CI systems\npytest --junitxml=test-results.xml\n</code></pre>"},{"location":"testing/#continuous-integration","title":"\ud83d\udd04 Continuous Integration","text":""},{"location":"testing/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.9, 3.10, 3.11, 3.12]\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install -e .[all]\n        pip install pytest pytest-asyncio pytest-cov\n\n    - name: Run tests\n      run: pytest --cov=textxtract\n</code></pre>"},{"location":"testing/#validation-checklist","title":"\u2705 Validation Checklist","text":"<p>Before submitting changes, ensure:</p> <ul> <li>[ ] All existing tests pass</li> <li>[ ] New features have corresponding tests</li> <li>[ ] Error conditions are tested</li> <li>[ ] Both sync and async methods are tested</li> <li>[ ] Documentation examples are tested</li> <li>[ ] Performance regressions are checked</li> <li>[ ] Memory leaks are verified</li> </ul>"},{"location":"testing/#troubleshooting-tests","title":"\ud83c\udd98 Troubleshooting Tests","text":""},{"location":"testing/#common-issues","title":"Common Issues","text":"<p>Missing dependencies: <pre><code>pip install textxtract[all] pytest pytest-asyncio\n</code></pre></p> <p>Import errors: <pre><code># Ensure correct import\nfrom textxtract import SyncTextExtractor  # Correct\nfrom text_extractor import SyncTextExtractor  # Wrong\n</code></pre></p> <p>Async test issues: <pre><code># Ensure pytest-asyncio is installed and configured\npytest.mark.asyncio  # Required for async tests\n</code></pre></p> <p>File not found errors: <pre><code># Use absolute paths in tests\nTEST_FILES_DIR = Path(__file__).parent / \"files\"\nfile_path = TEST_FILES_DIR / \"test_file.txt\"\n</code></pre></p> <p>For more testing help, see the API Reference or Usage Guide.</p>"},{"location":"usage/","title":"Usage","text":"<p>The text extractor provides both synchronous and asynchronous extractors that support both file paths and bytes input for maximum flexibility.</p>"},{"location":"usage/#basic-usage","title":"Basic Usage","text":"<pre><code>from textxtract import SyncTextExtractor, AsyncTextExtractor\n\n# Synchronous extractor\nsync_extractor = SyncTextExtractor()\n\n# Asynchronous extractor\nasync_extractor = AsyncTextExtractor()\n</code></pre>"},{"location":"usage/#extracting-from-file-paths","title":"Extracting from File Paths","text":""},{"location":"usage/#synchronous","title":"Synchronous","text":"<pre><code>from textxtract import SyncTextExtractor\n\nextractor = SyncTextExtractor()\n\n# From file path (string)\ntext = extractor.extract(\"document.pdf\")\n\n# From Path object\nfrom pathlib import Path\ntext = extractor.extract(Path(\"document.pdf\"))\n</code></pre>"},{"location":"usage/#asynchronous","title":"Asynchronous","text":"<pre><code>from textxtract import AsyncTextExtractor\nimport asyncio\n\nextractor = AsyncTextExtractor()\n\n# Async extraction from file path\ntext = await extractor.extract(\"document.pdf\")\n\n# Or using asyncio.run for simple cases\ntext = asyncio.run(extractor.extract(\"document.pdf\"))\n</code></pre>"},{"location":"usage/#extracting-from-bytes","title":"Extracting from Bytes","text":"<p>When working with bytes, the filename parameter is required for file type detection:</p>"},{"location":"usage/#synchronous_1","title":"Synchronous","text":"<pre><code>from textxtract import SyncTextExtractor\n\nextractor = SyncTextExtractor()\n\n# From bytes (filename required for extension detection)\nwith open(\"document.pdf\", \"rb\") as f:\n    file_bytes = f.read()\n\ntext = extractor.extract(file_bytes, \"document.pdf\")\n</code></pre>"},{"location":"usage/#asynchronous_1","title":"Asynchronous","text":"<pre><code>from textxtract import AsyncTextExtractor\n\nextractor = AsyncTextExtractor()\n\n# Async extraction from bytes\nwith open(\"document.pdf\", \"rb\") as f:\n    file_bytes = f.read()\n\ntext = await extractor.extract(file_bytes, \"document.pdf\")\n</code></pre>"},{"location":"usage/#supported-file-types","title":"Supported File Types","text":"Extension Extra Dependency Handler .pdf [pdf] PyMuPDF .docx [docx] python-docx .doc [doc] antiword .txt stdlib .md [md] markdown .rtf [rtf] striprtf .html/.htm [html] beautifulsoup4 .csv stdlib .json stdlib .xml [xml] lxml .zip stdlib"},{"location":"usage/#configuration","title":"Configuration","text":"<pre><code>from textxtract import SyncTextExtractor\nfrom textxtract import ExtractorConfig\n\n# Custom configuration\nconfig = ExtractorConfig(\n    encoding=\"utf-8\",\n    logging_level=\"DEBUG\"\n)\n\nextractor = SyncTextExtractor(config)\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<p>All operations raise custom exceptions from <code>textxtract.core.exceptions</code>:</p> <pre><code>from textxtract import SyncTextExtractor\nfrom textxtract.exceptions import (\n    ExtractionError,\n    InvalidFileError,\n    FileTypeNotSupportedError\n)\n\nextractor = SyncTextExtractor()\n\ntry:\n    text = extractor.extract(\"document.pdf\")\nexcept FileTypeNotSupportedError:\n    print(\"File type not supported\")\nexcept InvalidFileError:\n    print(\"File is invalid or corrupted\")\nexcept ExtractionError:\n    print(\"General extraction error\")\n</code></pre>"},{"location":"usage/#context-manager-support","title":"Context Manager Support","text":"<p>Both extractors support context managers for proper resource cleanup:</p>"},{"location":"usage/#synchronous_2","title":"Synchronous","text":"<pre><code>from textxtract import SyncTextExtractor\n\nwith SyncTextExtractor() as extractor:\n    text = extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"usage/#asynchronous_2","title":"Asynchronous","text":"<pre><code>from textxtract import AsyncTextExtractor\n\nasync with AsyncTextExtractor() as extractor:\n    text = await extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"usage/#logging","title":"Logging","text":"<p>Configure logging to see extraction progress:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Now extraction will log debug information\nfrom textxtract import SyncTextExtractor\nextractor = SyncTextExtractor()\ntext = extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"usage/#batch-processing","title":"Batch Processing","text":""},{"location":"usage/#synchronous-batch-processing","title":"Synchronous Batch Processing","text":"<pre><code>from textxtract import SyncTextExtractor\nfrom pathlib import Path\n\ndef process_files_sync(file_paths):\n    extractor = SyncTextExtractor()\n    results = []\n    for path in file_paths:\n        try:\n            text = extractor.extract(path)\n            results.append({\"file\": path, \"text\": text, \"success\": True})\n        except Exception as e:\n            results.append({\"file\": path, \"error\": str(e), \"success\": False})\n    return results\n\nfile_paths = [Path(\"doc1.pdf\"), Path(\"doc2.docx\"), Path(\"doc3.txt\")]\nresults = process_files_sync(file_paths)\n</code></pre>"},{"location":"usage/#asynchronous-batch-processing","title":"Asynchronous Batch Processing","text":"<pre><code>import asyncio\nfrom textxtract import AsyncTextExtractor\nfrom pathlib import Path\n\nasync def process_files_async(file_paths):\n    async with AsyncTextExtractor() as extractor:\n        tasks = [extractor.extract(path) for path in file_paths]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        return results\n\n# Process multiple files concurrently\nfile_paths = [Path(\"doc1.pdf\"), Path(\"doc2.docx\"), Path(\"doc3.txt\")]\nresults = asyncio.run(process_files_async(file_paths))\n</code></pre>"},{"location":"usage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/#custom-configuration-per-extraction","title":"Custom Configuration per Extraction","text":"<pre><code>from textxtract import SyncTextExtractor\n\nextractor = SyncTextExtractor()\n\n# Override config for specific extraction\ncustom_config = {\n    \"encoding\": \"latin-1\",\n    \"max_file_size\": 50 * 1024 * 1024  # 50MB\n}\n\ntext = extractor.extract(\"document.pdf\", config=custom_config)\n</code></pre>"},{"location":"usage/#working-with-large-files","title":"Working with Large Files","text":"<pre><code>from textxtract import AsyncTextExtractor\nimport asyncio\n\nasync def extract_large_file():\n    async with AsyncTextExtractor() as extractor:\n        # For large files, async extraction is recommended\n        config = {\"max_file_size\": 500 * 1024 * 1024}  # 500MB\n        text = await extractor.extract(\"large_document.pdf\", config=config)\n        return text\n\ntext = asyncio.run(extract_large_file())\n</code></pre>"},{"location":"usage/#important-notes","title":"Important Notes","text":"<ol> <li>File Extensions Required: Files must have extensions for type detection</li> <li>Filename Required for Bytes: When passing bytes, filename parameter is mandatory</li> <li>Async vs Sync: Use AsyncTextExtractor for I/O-bound operations and concurrent processing</li> <li>Resource Cleanup: Use context managers for automatic resource cleanup</li> <li>Error Handling: Always handle exceptions appropriately for production use</li> </ol>"},{"location":"reference/","title":"API Reference","text":"<p>Welcome to the Text Extractor API reference documentation.</p>"},{"location":"reference/#main-components","title":"Main Components","text":"<ul> <li>Sync Extractor - Synchronous text extraction</li> <li>Async Extractor - Asynchronous text extraction</li> <li>Core Components - Base classes and utilities</li> <li>Handlers - File format handlers</li> </ul>"},{"location":"reference/__init__/","title":"Text Extractor Package","text":"<p>Text Extractor package - Professional text extraction from multiple file formats.</p> <p>Modules:</p> Name Description <code>aio</code> <p>Asynchronous extraction logic package.</p> <code>core</code> <p>Core components for textxtract package.</p> <code>exceptions</code> <code>handlers</code> <p>File type-specific handlers package.</p> <code>sync</code> <p>Synchronous extraction logic package.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p> <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p> <code>SyncTextExtractor</code> <p>Synchronous text extractor with support for file paths and bytes.</p>"},{"location":"reference/__init__/#textxtract-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['SyncTextExtractor', 'AsyncTextExtractor', 'ExtractorConfig']\n</code></pre>"},{"location":"reference/__init__/#textxtract.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = '0.2.2'\n</code></pre>"},{"location":"reference/__init__/#textxtract-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.extract","title":"extract  <code>async</code>","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.extract(source)","title":"<code>source</code>","text":""},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/__init__/#textxtract.AsyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/__init__/#textxtract.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.ExtractorConfig.custom_handlers","title":"custom_handlers  <code>instance-attribute</code>","text":"<pre><code>custom_handlers = custom_handlers or {}\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.encoding","title":"encoding  <code>instance-attribute</code>","text":"<pre><code>encoding = _validate_encoding(encoding)\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.extra_config","title":"extra_config  <code>instance-attribute</code>","text":"<pre><code>extra_config = kwargs\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.logging_format","title":"logging_format  <code>instance-attribute</code>","text":"<pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.logging_level","title":"logging_level  <code>instance-attribute</code>","text":"<pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.max_file_size","title":"max_file_size  <code>instance-attribute</code>","text":"<pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.max_memory_usage","title":"max_memory_usage  <code>instance-attribute</code>","text":"<pre><code>max_memory_usage = max_memory_usage\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.ExtractorConfig.__init__","title":"__init__","text":"<pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.get_handler","title":"get_handler","text":"<pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.get_handler_config","title":"get_handler_config","text":"<pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.register_handler","title":"register_handler","text":"<pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre>"},{"location":"reference/__init__/#textxtract.ExtractorConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with support for file paths and bytes.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file path or bytes.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text\n            try:\n                result = handler.extract(file_path, config or self.config.__dict__)\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def _prepare_file_path(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            temp_path = create_temp_file(\n                source, filename, config and config.get(\"max_file_size\")\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file path or bytes.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text\n        try:\n            result = handler.extract(file_path, config or self.config.__dict__)\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract(source)","title":"<code>source</code>","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/__init__/#textxtract-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.aio","title":"aio","text":"<p>Asynchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p>"},{"location":"reference/__init__/#textxtract.aio-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.aio.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncTextExtractor']\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.aio.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.AsyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.AsyncTextExtractor-functions","title":"Functions","text":"__aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre> <code></code> extract <code>async</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.aio.extractor","title":"extractor","text":"<p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/__init__/#textxtract.aio.extractor-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.extractor-classes","title":"Classes","text":"AsyncTextExtractor <p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre> Attributes <code></code> config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre> Functions <code></code> __aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre> <code></code> extract <code>async</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.core","title":"core","text":"<p>Core components for textxtract package.</p> <p>Modules:</p> Name Description <code>base</code> <p>Abstract base classes for text extraction.</p> <code>config</code> <p>Configuration and customization for textxtract package.</p> <code>exceptions</code> <p>Custom exceptions for textxtract package.</p> <code>logging_config</code> <p>Logging configuration for textxtract package.</p> <code>registry</code> <p>Handler registry for centralized handler management.</p> <code>utils</code> <p>Utility functions for textxtract package.</p>"},{"location":"reference/__init__/#textxtract.core-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.core.base","title":"base","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/__init__/#textxtract.core.base-classes","title":"Classes","text":"FileTypeHandler <p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre> Functions <code></code> extract <code>abstractmethod</code> <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> TextExtractor <p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n        pass\n</code></pre> Functions <code></code> extract <code>abstractmethod</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.config","title":"config","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/__init__/#textxtract.core.config-classes","title":"Classes","text":"ExtractorConfig <p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> Attributes <code></code> custom_handlers <code>instance-attribute</code> <pre><code>custom_handlers = custom_handlers or {}\n</code></pre> <code></code> encoding <code>instance-attribute</code> <pre><code>encoding = _validate_encoding(encoding)\n</code></pre> <code></code> extra_config <code>instance-attribute</code> <pre><code>extra_config = kwargs\n</code></pre> <code></code> logging_format <code>instance-attribute</code> <pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre> <code></code> logging_level <code>instance-attribute</code> <pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre> <code></code> max_file_size <code>instance-attribute</code> <pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre> <code></code> max_memory_usage <code>instance-attribute</code> <pre><code>max_memory_usage = max_memory_usage\n</code></pre> <code></code> timeout <code>instance-attribute</code> <pre><code>timeout = _validate_timeout(timeout)\n</code></pre> Functions <code></code> __init__ <pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre> <code></code> __repr__ <pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> <code></code> from_file <code>classmethod</code> <pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre> <code></code> get_handler <pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre> <code></code> get_handler_config <pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre> <code></code> to_dict <pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.exceptions","title":"exceptions","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/__init__/#textxtract.core.exceptions-classes","title":"Classes","text":"ExtractionError <p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre> <code></code> ExtractionTimeoutError <p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre> <code></code> FileTypeNotSupportedError <p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre> <code></code> InvalidFileError <p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.logging_config","title":"logging_config","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/__init__/#textxtract.core.logging_config-functions","title":"Functions","text":"setup_logging <pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.registry","title":"registry","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/__init__/#textxtract.core.registry-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.registry')\n</code></pre> <code></code> registry <code>module-attribute</code> <pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.registry-classes","title":"Classes","text":"HandlerRegistry <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - striprtf not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre> Functions <code></code> __init__ <pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre> <code></code> __new__ <pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre> <code></code> get_handler <code>cached</code> <pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre> <code></code> get_supported_extensions <pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre> <code></code> is_supported <pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.utils","title":"utils","text":"<p>Utility functions for textxtract package.</p> <p>Classes:</p> Name Description <code>FileInfo</code> <p>File information data class.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/__init__/#textxtract.core.utils-attributes","title":"Attributes","text":"DEFAULT_MAX_FILE_SIZE <code>module-attribute</code> <pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre> <code></code> DEFAULT_MAX_TEMP_FILES <code>module-attribute</code> <pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.utils-classes","title":"Classes","text":"FileInfo <code>dataclass</code> <p>File information data class.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>extension</code> <code>str</code> <code>filename</code> <code>str</code> <code>is_temp</code> <code>bool</code> <code>size_bytes</code> <code>int</code> <code>size_kb</code> <code>float</code> <p>File size in KB.</p> <code>size_mb</code> <code>float</code> Source code in <code>textxtract/core/utils.py</code> <pre><code>@dataclass\nclass FileInfo:\n    \"\"\"File information data class.\"\"\"\n\n    filename: str\n    size_bytes: int\n    size_mb: float\n    extension: str\n    is_temp: bool = False\n\n    @property\n    def size_kb(self) -&gt; float:\n        \"\"\"File size in KB.\"\"\"\n        return round(self.size_bytes / 1024, 2)\n</code></pre> Attributes <code></code> extension <code>instance-attribute</code> <pre><code>extension\n</code></pre> <code></code> filename <code>instance-attribute</code> <pre><code>filename\n</code></pre> <code></code> is_temp <code>class-attribute</code> <code>instance-attribute</code> <pre><code>is_temp = False\n</code></pre> <code></code> size_bytes <code>instance-attribute</code> <pre><code>size_bytes\n</code></pre> <code></code> size_kb <code>property</code> <pre><code>size_kb\n</code></pre> <p>File size in KB.</p> <code></code> size_mb <code>instance-attribute</code> <pre><code>size_mb\n</code></pre> Functions <code></code> __init__ <pre><code>__init__(filename, size_bytes, size_mb, extension, is_temp=False)\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.utils-functions","title":"Functions","text":"create_temp_file <pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre> <code></code> get_file_info <pre><code>get_file_info(source, filename=None)\n</code></pre> <p>Get file information for logging and debugging.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FileInfo</code> <code>FileInfo</code> <p>Data class with file information</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(\n    source: Union[Path, str, bytes], filename: Optional[str] = None\n) -&gt; FileInfo:\n    \"\"\"\n    Get file information for logging and debugging.\n\n    Args:\n        source: File path or file bytes\n        filename: Required if source is bytes, optional for file paths\n\n    Returns:\n        FileInfo: Data class with file information\n    \"\"\"\n    if isinstance(source, bytes):\n        if not filename:\n            raise ValueError(\"filename is required when source is bytes\")\n        return FileInfo(\n            filename=filename,\n            size_bytes=len(source),\n            size_mb=round(len(source) / (1024 * 1024), 2),\n            extension=Path(filename).suffix.lower(),\n            is_temp=True,\n        )\n    else:\n        # Handle file path\n        file_path = Path(source)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n        if not file_path.is_file():\n            raise ValueError(f\"Path is not a file: {file_path}\")\n\n        file_size = file_path.stat().st_size\n        return FileInfo(\n            filename=filename or file_path.name,\n            size_bytes=file_size,\n            size_mb=round(file_size / (1024 * 1024), 2),\n            extension=file_path.suffix.lower(),\n            is_temp=False,\n        )\n</code></pre> <code></code> safe_unlink <pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre> <code></code> validate_file_extension <pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre> <code></code> validate_file_size <pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre> <code></code> validate_filename <pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/__init__/#textxtract.exceptions","title":"exceptions","text":"<p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/__init__/#textxtract.exceptions-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.exceptions.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ExtractionError', 'InvalidFileError', 'FileTypeNotSupportedError', 'ExtractionTimeoutError']\n</code></pre>"},{"location":"reference/__init__/#textxtract.exceptions-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers","title":"handlers","text":"<p>File type-specific handlers package.</p> <p>Modules:</p> Name Description <code>csv</code> <p>CSV file handler for text extraction.</p> <code>doc</code> <p>DOC file handler for text extraction.</p> <code>docx</code> <p>DOCX file handler for comprehensive text extraction.</p> <code>html</code> <p>HTML file handler for text extraction.</p> <code>json</code> <p>JSON file handler for text extraction.</p> <code>md</code> <p>Markdown (.md) file handler for text extraction.</p> <code>pdf</code> <p>PDF file handler for text extraction.</p> <code>rtf</code> <p>RTF file handler for text extraction.</p> <code>txt</code> <p>TXT file handler for text extraction.</p> <code>xml</code> <p>XML file handler for text extraction.</p> <code>zip</code> <p>ZIP file handler for text extraction.</p>"},{"location":"reference/__init__/#textxtract.handlers-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.handlers.csv","title":"csv","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/__init__/#textxtract.handlers.csv-classes","title":"Classes","text":"CSVHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.doc","title":"doc","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/__init__/#textxtract.handlers.doc-classes","title":"Classes","text":"DOCHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            # Check if the error is due to missing libreoffice dependency\n            if (\n                \"libreoffice\" in error_msg.lower()\n                or \"no such file or directory\" in error_msg.lower()\n            ):\n                # Trigger fallback by raising FileNotFoundError\n                raise FileNotFoundError(\n                    \"antiword requires libreoffice which is not available\"\n                )\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self,\n        file_path: Path,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.docx","title":"docx","text":"<p>DOCX file handler for comprehensive text extraction.</p> <p>This handler extracts text from: - Document paragraphs - Tables and cells - Headers and footers - Text boxes and shapes - Footnotes and endnotes (if available)</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p>"},{"location":"reference/__init__/#textxtract.handlers.docx-classes","title":"Classes","text":"DOCXHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p> <pre><code>This handler provides complete text extraction from Microsoft Word documents,\nincluding all document elements such as paragraphs, tables, headers, footers,\ntext boxes, and footnotes. It's designed to handle complex document layouts\ncommonly found in resumes, reports, and structured documents.\n\nFeatures:\n    - Extracts text from document body paragraphs\n    - Processes table content with cell-by-cell extraction\n    - Captures header and footer text from all sections\n    - Attempts to extract text from embedded text boxes and shapes\n    - Handles footnotes and endnotes when available\n    - Deduplicates repeated content\n    - Cleans and normalizes extracted text\n\nExample:\n    &gt;&gt;&gt; handler = DOCXHandler()\n    &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n    &gt;&gt;&gt; print(text)\n    \"Document title\n</code></pre> <p>Paragraph content... Table data | Column 2...\"</p> <pre><code>    &gt;&gt;&gt; # Async extraction\n    &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n</code></pre> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text from a DOCX file with comprehensive content capture.</p> <code>extract_async</code> <p>Asynchronously extract text from a DOCX file.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Enhanced handler for comprehensive text extraction from DOCX files.\n\n    This handler provides complete text extraction from Microsoft Word documents,\n    including all document elements such as paragraphs, tables, headers, footers,\n    text boxes, and footnotes. It's designed to handle complex document layouts\n    commonly found in resumes, reports, and structured documents.\n\n    Features:\n        - Extracts text from document body paragraphs\n        - Processes table content with cell-by-cell extraction\n        - Captures header and footer text from all sections\n        - Attempts to extract text from embedded text boxes and shapes\n        - Handles footnotes and endnotes when available\n        - Deduplicates repeated content\n        - Cleans and normalizes extracted text\n\n    Example:\n        &gt;&gt;&gt; handler = DOCXHandler()\n        &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n        &gt;&gt;&gt; print(text)\n        \"Document title\\nParagraph content...\\nTable data | Column 2...\"\n\n        &gt;&gt;&gt; # Async extraction\n        &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n    \"\"\"\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"Clean and normalize extracted text.\n\n        Performs various text cleaning operations to improve readability\n        and consistency of extracted content.\n\n        Args:\n            text (str): Raw text to be cleaned.\n\n        Returns:\n            str: Cleaned and normalized text with proper spacing and formatting.\n\n        Note:\n            - Normalizes multiple whitespace characters to single spaces\n            - Removes excessive consecutive dots/periods\n            - Fixes spacing around punctuation marks\n            - Strips leading and trailing whitespace\n        \"\"\"\n        if not text:\n            return \"\"\n\n        # Normalize whitespace (replace multiple spaces, tabs, newlines with single space)\n        text = re.sub(r'\\s+', ' ', text)\n        # Remove excessive dots/periods (likely formatting artifacts)\n        text = re.sub(r'\\.{2,}', ' ', text)\n        # Clean up spacing around punctuation (remove spaces before punctuation)\n        text = re.sub(r'\\s+([.!?,:;])', r'\\1', text)\n        return text.strip()\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n        Performs thorough text extraction from all available document elements\n        including body text, tables, headers, footers, and embedded content.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            - Text is deduplicated to avoid repeated content from overlapping elements\n            - Table content is formatted with pipe separators between columns\n            - Special content (footnotes, text boxes) is labeled with descriptive tags\n            - Sentence breaks are automatically inserted for better readability\n        \"\"\"\n        try:\n            from docx import Document\n            import re\n\n            # Load the document\n            doc = Document(file_path)\n            text_parts = []\n            processed_text = set()  # Track processed text to avoid duplicates\n\n            # Extract text from main document paragraphs\n            for paragraph in doc.paragraphs:\n                text = paragraph.text.strip()\n                if text and text not in processed_text:\n                    text_parts.append(text)\n                    processed_text.add(text)\n\n            # Extract text from all tables in the document\n            for table in doc.tables:\n                table_texts = []\n                for row in table.rows:\n                    row_text = []\n                    for cell in row.cells:\n                        # Process each paragraph within the cell\n                        cell_paragraphs = []\n                        for paragraph in cell.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                cell_paragraphs.append(text)\n                                processed_text.add(text)\n                        if cell_paragraphs:\n                            row_text.append(\" \".join(cell_paragraphs))\n                    if row_text:\n                        # Join cell contents with pipe separator for table structure\n                        table_texts.append(\" | \".join(row_text))\n\n                # Add table content to main text collection\n                if table_texts:\n                    text_parts.extend(table_texts)\n\n            # Extract text from headers and footers across all document sections\n            for section in doc.sections:\n                # Process header content\n                if section.header:\n                    for paragraph in section.header.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n                # Process footer content\n                if section.footer:\n                    for paragraph in section.footer.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n            # Attempt to extract footnotes and endnotes (may not be available in all documents)\n            try:\n                # Extract footnotes if present\n                if hasattr(doc, 'footnotes'):\n                    for footnote in doc.footnotes:\n                        for paragraph in footnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Footnote: {text}]\")\n                                processed_text.add(text)\n\n                # Extract endnotes if present\n                if hasattr(doc, 'endnotes'):\n                    for endnote in doc.endnotes:\n                        for paragraph in endnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Endnote: {text}]\")\n                                processed_text.add(text)\n            except Exception:\n                # Footnote/endnote extraction is optional - continue if it fails\n                pass\n\n            # Attempt to extract text from embedded text boxes and shapes using XML parsing\n            try:\n                from docx.oxml.ns import qn\n\n                # Iterate through document XML elements to find drawing content\n                for element in doc.element.body.iter():\n                    if element.tag.endswith('}txbxContent'):\n                        # Extract text from text box elements\n                        for para in element.iter():\n                            if para.tag.endswith('}t') and para.text:\n                                text = para.text.strip()\n                                if text and text not in processed_text:\n                                    text_parts.append(f\"[TextBox: {text}]\")\n                                    processed_text.add(text)\n            except Exception:\n                # Text box extraction is optional - continue if it fails\n                pass\n\n            # Process and format the final output\n            if text_parts:\n                # Clean each text part and filter out empty content\n                cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n                result = \"\\n\".join(cleaned_parts)\n\n                # Add proper sentence breaks for improved readability\n                result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n                return result.strip()\n\n            return \"\"\n\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Asynchronously extract text from a DOCX file.\n\n        Provides non-blocking text extraction by running the synchronous\n        extraction method in a separate thread.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            This method uses asyncio.to_thread() to run the synchronous extraction\n            in a thread pool, making it suitable for async/await usage patterns.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text from a DOCX file with comprehensive content capture.</p> <p>Performs thorough text extraction from all available document elements including body text, tables, headers, footers, and embedded content.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>config</code> <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <ul> <li>Text is deduplicated to avoid repeated content from overlapping elements</li> <li>Table content is formatted with pipe separators between columns</li> <li>Special content (footnotes, text boxes) is labeled with descriptive tags</li> <li>Sentence breaks are automatically inserted for better readability</li> </ul> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n    Performs thorough text extraction from all available document elements\n    including body text, tables, headers, footers, and embedded content.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        - Text is deduplicated to avoid repeated content from overlapping elements\n        - Table content is formatted with pipe separators between columns\n        - Special content (footnotes, text boxes) is labeled with descriptive tags\n        - Sentence breaks are automatically inserted for better readability\n    \"\"\"\n    try:\n        from docx import Document\n        import re\n\n        # Load the document\n        doc = Document(file_path)\n        text_parts = []\n        processed_text = set()  # Track processed text to avoid duplicates\n\n        # Extract text from main document paragraphs\n        for paragraph in doc.paragraphs:\n            text = paragraph.text.strip()\n            if text and text not in processed_text:\n                text_parts.append(text)\n                processed_text.add(text)\n\n        # Extract text from all tables in the document\n        for table in doc.tables:\n            table_texts = []\n            for row in table.rows:\n                row_text = []\n                for cell in row.cells:\n                    # Process each paragraph within the cell\n                    cell_paragraphs = []\n                    for paragraph in cell.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            cell_paragraphs.append(text)\n                            processed_text.add(text)\n                    if cell_paragraphs:\n                        row_text.append(\" \".join(cell_paragraphs))\n                if row_text:\n                    # Join cell contents with pipe separator for table structure\n                    table_texts.append(\" | \".join(row_text))\n\n            # Add table content to main text collection\n            if table_texts:\n                text_parts.extend(table_texts)\n\n        # Extract text from headers and footers across all document sections\n        for section in doc.sections:\n            # Process header content\n            if section.header:\n                for paragraph in section.header.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n            # Process footer content\n            if section.footer:\n                for paragraph in section.footer.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n        # Attempt to extract footnotes and endnotes (may not be available in all documents)\n        try:\n            # Extract footnotes if present\n            if hasattr(doc, 'footnotes'):\n                for footnote in doc.footnotes:\n                    for paragraph in footnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Footnote: {text}]\")\n                            processed_text.add(text)\n\n            # Extract endnotes if present\n            if hasattr(doc, 'endnotes'):\n                for endnote in doc.endnotes:\n                    for paragraph in endnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Endnote: {text}]\")\n                            processed_text.add(text)\n        except Exception:\n            # Footnote/endnote extraction is optional - continue if it fails\n            pass\n\n        # Attempt to extract text from embedded text boxes and shapes using XML parsing\n        try:\n            from docx.oxml.ns import qn\n\n            # Iterate through document XML elements to find drawing content\n            for element in doc.element.body.iter():\n                if element.tag.endswith('}txbxContent'):\n                    # Extract text from text box elements\n                    for para in element.iter():\n                        if para.tag.endswith('}t') and para.text:\n                            text = para.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[TextBox: {text}]\")\n                                processed_text.add(text)\n        except Exception:\n            # Text box extraction is optional - continue if it fails\n            pass\n\n        # Process and format the final output\n        if text_parts:\n            # Clean each text part and filter out empty content\n            cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n            result = \"\\n\".join(cleaned_parts)\n\n            # Add proper sentence breaks for improved readability\n            result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n            return result.strip()\n\n        return \"\"\n\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Asynchronously extract text from a DOCX file.</p> <p>Provides non-blocking text extraction by running the synchronous extraction method in a separate thread.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>config</code> <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <p>This method uses asyncio.to_thread() to run the synchronous extraction in a thread pool, making it suitable for async/await usage patterns.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Asynchronously extract text from a DOCX file.\n\n    Provides non-blocking text extraction by running the synchronous\n    extraction method in a separate thread.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        This method uses asyncio.to_thread() to run the synchronous extraction\n        in a thread pool, making it suitable for async/await usage patterns.\n    \"\"\"\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.html","title":"html","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/__init__/#textxtract.handlers.html-classes","title":"Classes","text":"HTMLHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.json","title":"json","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/__init__/#textxtract.handlers.json-classes","title":"Classes","text":"JSONHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.md","title":"md","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/__init__/#textxtract.handlers.md-classes","title":"Classes","text":"MDHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.pdf","title":"pdf","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/__init__/#textxtract.handlers.pdf-classes","title":"Classes","text":"PDFHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.rtf","title":"rtf","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/__init__/#textxtract.handlers.rtf-classes","title":"Classes","text":"RTFHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.txt","title":"txt","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/__init__/#textxtract.handlers.txt-classes","title":"Classes","text":"TXTHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.xml","title":"xml","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/__init__/#textxtract.handlers.xml-classes","title":"Classes","text":"XMLHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.zip","title":"zip","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/__init__/#textxtract.handlers.zip-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.zip-classes","title":"Classes","text":"ZIPHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Attributes <code></code> MAX_EXTRACT_SIZE <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre> <code></code> MAX_FILES <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_FILES = 1000\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.sync","title":"sync","text":"<p>Synchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Synchronous text extraction logic with support for file paths and bytes.</p>"},{"location":"reference/__init__/#textxtract.sync-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.sync.extractor","title":"extractor","text":"<p>Synchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/__init__/#textxtract.sync.extractor-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/__init__/#textxtract.sync.extractor-classes","title":"Classes","text":"SyncTextExtractor <p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with support for file paths and bytes.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file path or bytes.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text\n            try:\n                result = handler.extract(file_path, config or self.config.__dict__)\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def _prepare_file_path(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            temp_path = create_temp_file(\n                source, filename, config and config.get(\"max_file_size\")\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre> Attributes <code></code> config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre> Functions <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre> <code></code> extract <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file path or bytes.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text\n        try:\n            result = handler.extract(file_path, config or self.config.__dict__)\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/exceptions/","title":"Exceptions Module","text":"<p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/exceptions/#textxtract.exceptions-attributes","title":"Attributes","text":""},{"location":"reference/exceptions/#textxtract.exceptions.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ExtractionError', 'InvalidFileError', 'FileTypeNotSupportedError', 'ExtractionTimeoutError']\n</code></pre>"},{"location":"reference/exceptions/#textxtract.exceptions-classes","title":"Classes","text":""},{"location":"reference/exceptions/#textxtract.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#textxtract.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#textxtract.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#textxtract.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/aio/","title":"Aio Module","text":""},{"location":"reference/aio/#overview","title":"Overview","text":"<p>Asynchronous text extraction components.</p> <p>Asynchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p>"},{"location":"reference/aio/#textxtract.aio-attributes","title":"Attributes","text":""},{"location":"reference/aio/#textxtract.aio.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncTextExtractor']\n</code></pre>"},{"location":"reference/aio/#textxtract.aio-classes","title":"Classes","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract","title":"extract  <code>async</code>","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract(source)","title":"<code>source</code>","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/aio/#textxtract.aio-modules","title":"Modules","text":""},{"location":"reference/aio/#textxtract.aio.extractor","title":"extractor","text":"<p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/aio/#textxtract.aio.extractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/#textxtract.aio.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor-classes","title":"Classes","text":""},{"location":"reference/aio/#textxtract.aio.extractor.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor.AsyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor.AsyncTextExtractor-functions","title":"Functions","text":"__aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre> <code></code> extract <code>async</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/aio/__init__/","title":"Aio Module","text":"<p>Asynchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p>"},{"location":"reference/aio/__init__/#textxtract.aio-attributes","title":"Attributes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncTextExtractor']\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio-classes","title":"Classes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract","title":"extract  <code>async</code>","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract(source)","title":"<code>source</code>","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/aio/__init__/#textxtract.aio-modules","title":"Modules","text":""},{"location":"reference/aio/__init__/#textxtract.aio.extractor","title":"extractor","text":"<p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor-classes","title":"Classes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.extractor.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor.AsyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor.AsyncTextExtractor-functions","title":"Functions","text":"__aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre> <code></code> extract <code>async</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/aio/extractor/","title":"Extractor Module","text":"<p>Asynchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor-classes","title":"Classes","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with support for file paths and bytes.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Uses thread pool for I/O-bound operations.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit with cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit with cleanup.</p> <code>__init__</code> <code>extract</code> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with support for file paths and bytes.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Uses thread pool for I/O-bound operations.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s\",\n            self.config.__dict__,\n        )\n\n    async def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file path or bytes using thread pool.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        if getattr(self, \"_closed\", False):\n            raise RuntimeError(\"Extractor has been closed\")\n\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = await self._prepare_file_path_async(\n            source, filename, config\n        )\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text asynchronously\n            try:\n                loop = asyncio.get_running_loop()\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    file_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def _prepare_file_path_async(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction asynchronously.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            # Run temp file creation in thread pool to avoid blocking\n            loop = asyncio.get_running_loop()\n            temp_path = await loop.run_in_executor(\n                self._executor,\n                create_temp_file,\n                source,\n                filename,\n                config and config.get(\"max_file_size\"),\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with cleanup.\"\"\"\n        if hasattr(self, \"_executor\"):\n            self._executor.shutdown(wait=False)\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit with cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit with cleanup.\"\"\"\n    if hasattr(self, \"_executor\"):\n        self._executor.shutdown(wait=False)\n    self._closed = True\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s\",\n        self.config.__dict__,\n    )\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract","title":"extract  <code>async</code>","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text asynchronously from file path or bytes using thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file path or bytes using thread pool.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    if getattr(self, \"_closed\", False):\n        raise RuntimeError(\"Extractor has been closed\")\n\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = await self._prepare_file_path_async(\n        source, filename, config\n    )\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text asynchronously\n        try:\n            loop = asyncio.get_running_loop()\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                file_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract(source)","title":"<code>source</code>","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/core/","title":"Core Module","text":""},{"location":"reference/core/#overview","title":"Overview","text":"<p>Core components of the text extraction framework.</p> <ul> <li>Base Classes - Abstract base classes</li> <li>Configuration - Configuration management</li> <li>Exceptions - Custom exceptions</li> <li>Registry - Handler registry</li> <li>Utils - Utility functions</li> </ul> <p>Core components for textxtract package.</p> <p>Modules:</p> Name Description <code>base</code> <p>Abstract base classes for text extraction.</p> <code>config</code> <p>Configuration and customization for textxtract package.</p> <code>exceptions</code> <p>Custom exceptions for textxtract package.</p> <code>logging_config</code> <p>Logging configuration for textxtract package.</p> <code>registry</code> <p>Handler registry for centralized handler management.</p> <code>utils</code> <p>Utility functions for textxtract package.</p>"},{"location":"reference/core/#textxtract.core-modules","title":"Modules","text":""},{"location":"reference/core/#textxtract.core.base","title":"base","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/core/#textxtract.core.base-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.base.FileTypeHandler","title":"FileTypeHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.base.FileTypeHandler-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.base.TextExtractor","title":"TextExtractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.base.TextExtractor-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.config","title":"config","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/core/#textxtract.core.config-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.config.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.config.ExtractorConfig-attributes","title":"Attributes","text":"custom_handlers <code>instance-attribute</code> <pre><code>custom_handlers = custom_handlers or {}\n</code></pre> <code></code> encoding <code>instance-attribute</code> <pre><code>encoding = _validate_encoding(encoding)\n</code></pre> <code></code> extra_config <code>instance-attribute</code> <pre><code>extra_config = kwargs\n</code></pre> <code></code> logging_format <code>instance-attribute</code> <pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre> <code></code> logging_level <code>instance-attribute</code> <pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre> <code></code> max_file_size <code>instance-attribute</code> <pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre> <code></code> max_memory_usage <code>instance-attribute</code> <pre><code>max_memory_usage = max_memory_usage\n</code></pre> <code></code> timeout <code>instance-attribute</code> <pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/core/#textxtract.core.config.ExtractorConfig-functions","title":"Functions","text":"__init__ <pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre> <code></code> __repr__ <pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> <code></code> from_file <code>classmethod</code> <pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre> <code></code> get_handler <pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre> <code></code> get_handler_config <pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre> <code></code> to_dict <pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions","title":"exceptions","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/core/#textxtract.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.logging_config","title":"logging_config","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/core/#textxtract.core.logging_config-functions","title":"Functions","text":""},{"location":"reference/core/#textxtract.core.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry","title":"registry","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/core/#textxtract.core.registry-attributes","title":"Attributes","text":""},{"location":"reference/core/#textxtract.core.registry.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.registry')\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.registry.HandlerRegistry","title":"HandlerRegistry","text":"<p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - striprtf not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry.HandlerRegistry-functions","title":"Functions","text":"__init__ <pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre> <code></code> __new__ <pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre> <code></code> get_handler <code>cached</code> <pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre> <code></code> get_supported_extensions <pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre> <code></code> is_supported <pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils","title":"utils","text":"<p>Utility functions for textxtract package.</p> <p>Classes:</p> Name Description <code>FileInfo</code> <p>File information data class.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/core/#textxtract.core.utils-attributes","title":"Attributes","text":""},{"location":"reference/core/#textxtract.core.utils.DEFAULT_MAX_FILE_SIZE","title":"DEFAULT_MAX_FILE_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.DEFAULT_MAX_TEMP_FILES","title":"DEFAULT_MAX_TEMP_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.utils.FileInfo","title":"FileInfo  <code>dataclass</code>","text":"<p>File information data class.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>extension</code> <code>str</code> <code>filename</code> <code>str</code> <code>is_temp</code> <code>bool</code> <code>size_bytes</code> <code>int</code> <code>size_kb</code> <code>float</code> <p>File size in KB.</p> <code>size_mb</code> <code>float</code> Source code in <code>textxtract/core/utils.py</code> <pre><code>@dataclass\nclass FileInfo:\n    \"\"\"File information data class.\"\"\"\n\n    filename: str\n    size_bytes: int\n    size_mb: float\n    extension: str\n    is_temp: bool = False\n\n    @property\n    def size_kb(self) -&gt; float:\n        \"\"\"File size in KB.\"\"\"\n        return round(self.size_bytes / 1024, 2)\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.FileInfo-attributes","title":"Attributes","text":"extension <code>instance-attribute</code> <pre><code>extension\n</code></pre> <code></code> filename <code>instance-attribute</code> <pre><code>filename\n</code></pre> <code></code> is_temp <code>class-attribute</code> <code>instance-attribute</code> <pre><code>is_temp = False\n</code></pre> <code></code> size_bytes <code>instance-attribute</code> <pre><code>size_bytes\n</code></pre> <code></code> size_kb <code>property</code> <pre><code>size_kb\n</code></pre> <p>File size in KB.</p> <code></code> size_mb <code>instance-attribute</code> <pre><code>size_mb\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.FileInfo-functions","title":"Functions","text":"__init__ <pre><code>__init__(filename, size_bytes, size_mb, extension, is_temp=False)\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils-functions","title":"Functions","text":""},{"location":"reference/core/#textxtract.core.utils.create_temp_file","title":"create_temp_file","text":"<pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.get_file_info","title":"get_file_info","text":"<pre><code>get_file_info(source, filename=None)\n</code></pre> <p>Get file information for logging and debugging.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FileInfo</code> <code>FileInfo</code> <p>Data class with file information</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(\n    source: Union[Path, str, bytes], filename: Optional[str] = None\n) -&gt; FileInfo:\n    \"\"\"\n    Get file information for logging and debugging.\n\n    Args:\n        source: File path or file bytes\n        filename: Required if source is bytes, optional for file paths\n\n    Returns:\n        FileInfo: Data class with file information\n    \"\"\"\n    if isinstance(source, bytes):\n        if not filename:\n            raise ValueError(\"filename is required when source is bytes\")\n        return FileInfo(\n            filename=filename,\n            size_bytes=len(source),\n            size_mb=round(len(source) / (1024 * 1024), 2),\n            extension=Path(filename).suffix.lower(),\n            is_temp=True,\n        )\n    else:\n        # Handle file path\n        file_path = Path(source)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n        if not file_path.is_file():\n            raise ValueError(f\"Path is not a file: {file_path}\")\n\n        file_size = file_path.stat().st_size\n        return FileInfo(\n            filename=filename or file_path.name,\n            size_bytes=file_size,\n            size_mb=round(file_size / (1024 * 1024), 2),\n            extension=file_path.suffix.lower(),\n            is_temp=False,\n        )\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.get_file_info(source)","title":"<code>source</code>","text":""},{"location":"reference/core/#textxtract.core.utils.get_file_info(filename)","title":"<code>filename</code>","text":""},{"location":"reference/core/#textxtract.core.utils.safe_unlink","title":"safe_unlink","text":"<pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.validate_file_extension","title":"validate_file_extension","text":"<pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.validate_file_size","title":"validate_file_size","text":"<pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.validate_filename","title":"validate_filename","text":"<pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/core/__init__/","title":"Core Module","text":"<p>Core components for textxtract package.</p> <p>Modules:</p> Name Description <code>base</code> <p>Abstract base classes for text extraction.</p> <code>config</code> <p>Configuration and customization for textxtract package.</p> <code>exceptions</code> <p>Custom exceptions for textxtract package.</p> <code>logging_config</code> <p>Logging configuration for textxtract package.</p> <code>registry</code> <p>Handler registry for centralized handler management.</p> <code>utils</code> <p>Utility functions for textxtract package.</p>"},{"location":"reference/core/__init__/#textxtract.core-modules","title":"Modules","text":""},{"location":"reference/core/__init__/#textxtract.core.base","title":"base","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/core/__init__/#textxtract.core.base-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.base.FileTypeHandler","title":"FileTypeHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.base.FileTypeHandler-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.base.TextExtractor","title":"TextExtractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.base.TextExtractor-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.config","title":"config","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/core/__init__/#textxtract.core.config-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.config.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.config.ExtractorConfig-attributes","title":"Attributes","text":"custom_handlers <code>instance-attribute</code> <pre><code>custom_handlers = custom_handlers or {}\n</code></pre> <code></code> encoding <code>instance-attribute</code> <pre><code>encoding = _validate_encoding(encoding)\n</code></pre> <code></code> extra_config <code>instance-attribute</code> <pre><code>extra_config = kwargs\n</code></pre> <code></code> logging_format <code>instance-attribute</code> <pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre> <code></code> logging_level <code>instance-attribute</code> <pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre> <code></code> max_file_size <code>instance-attribute</code> <pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre> <code></code> max_memory_usage <code>instance-attribute</code> <pre><code>max_memory_usage = max_memory_usage\n</code></pre> <code></code> timeout <code>instance-attribute</code> <pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.config.ExtractorConfig-functions","title":"Functions","text":"__init__ <pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre> <code></code> __repr__ <pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> <code></code> from_file <code>classmethod</code> <pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre> <code></code> get_handler <pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre> <code></code> get_handler_config <pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre> <code></code> to_dict <pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions","title":"exceptions","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/core/__init__/#textxtract.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.logging_config","title":"logging_config","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/core/__init__/#textxtract.core.logging_config-functions","title":"Functions","text":""},{"location":"reference/core/__init__/#textxtract.core.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry","title":"registry","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/core/__init__/#textxtract.core.registry-attributes","title":"Attributes","text":""},{"location":"reference/core/__init__/#textxtract.core.registry.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.registry')\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.registry.HandlerRegistry","title":"HandlerRegistry","text":"<p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - striprtf not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry.HandlerRegistry-functions","title":"Functions","text":"__init__ <pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre> <code></code> __new__ <pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre> <code></code> get_handler <code>cached</code> <pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre> <code></code> get_supported_extensions <pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre> <code></code> is_supported <pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils","title":"utils","text":"<p>Utility functions for textxtract package.</p> <p>Classes:</p> Name Description <code>FileInfo</code> <p>File information data class.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/core/__init__/#textxtract.core.utils-attributes","title":"Attributes","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.DEFAULT_MAX_FILE_SIZE","title":"DEFAULT_MAX_FILE_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.DEFAULT_MAX_TEMP_FILES","title":"DEFAULT_MAX_TEMP_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.FileInfo","title":"FileInfo  <code>dataclass</code>","text":"<p>File information data class.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>extension</code> <code>str</code> <code>filename</code> <code>str</code> <code>is_temp</code> <code>bool</code> <code>size_bytes</code> <code>int</code> <code>size_kb</code> <code>float</code> <p>File size in KB.</p> <code>size_mb</code> <code>float</code> Source code in <code>textxtract/core/utils.py</code> <pre><code>@dataclass\nclass FileInfo:\n    \"\"\"File information data class.\"\"\"\n\n    filename: str\n    size_bytes: int\n    size_mb: float\n    extension: str\n    is_temp: bool = False\n\n    @property\n    def size_kb(self) -&gt; float:\n        \"\"\"File size in KB.\"\"\"\n        return round(self.size_bytes / 1024, 2)\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.FileInfo-attributes","title":"Attributes","text":"extension <code>instance-attribute</code> <pre><code>extension\n</code></pre> <code></code> filename <code>instance-attribute</code> <pre><code>filename\n</code></pre> <code></code> is_temp <code>class-attribute</code> <code>instance-attribute</code> <pre><code>is_temp = False\n</code></pre> <code></code> size_bytes <code>instance-attribute</code> <pre><code>size_bytes\n</code></pre> <code></code> size_kb <code>property</code> <pre><code>size_kb\n</code></pre> <p>File size in KB.</p> <code></code> size_mb <code>instance-attribute</code> <pre><code>size_mb\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.FileInfo-functions","title":"Functions","text":"__init__ <pre><code>__init__(filename, size_bytes, size_mb, extension, is_temp=False)\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils-functions","title":"Functions","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.create_temp_file","title":"create_temp_file","text":"<pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.get_file_info","title":"get_file_info","text":"<pre><code>get_file_info(source, filename=None)\n</code></pre> <p>Get file information for logging and debugging.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FileInfo</code> <code>FileInfo</code> <p>Data class with file information</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(\n    source: Union[Path, str, bytes], filename: Optional[str] = None\n) -&gt; FileInfo:\n    \"\"\"\n    Get file information for logging and debugging.\n\n    Args:\n        source: File path or file bytes\n        filename: Required if source is bytes, optional for file paths\n\n    Returns:\n        FileInfo: Data class with file information\n    \"\"\"\n    if isinstance(source, bytes):\n        if not filename:\n            raise ValueError(\"filename is required when source is bytes\")\n        return FileInfo(\n            filename=filename,\n            size_bytes=len(source),\n            size_mb=round(len(source) / (1024 * 1024), 2),\n            extension=Path(filename).suffix.lower(),\n            is_temp=True,\n        )\n    else:\n        # Handle file path\n        file_path = Path(source)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n        if not file_path.is_file():\n            raise ValueError(f\"Path is not a file: {file_path}\")\n\n        file_size = file_path.stat().st_size\n        return FileInfo(\n            filename=filename or file_path.name,\n            size_bytes=file_size,\n            size_mb=round(file_size / (1024 * 1024), 2),\n            extension=file_path.suffix.lower(),\n            is_temp=False,\n        )\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.get_file_info(source)","title":"<code>source</code>","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.get_file_info(filename)","title":"<code>filename</code>","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.safe_unlink","title":"safe_unlink","text":"<pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.validate_file_extension","title":"validate_file_extension","text":"<pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.validate_file_size","title":"validate_file_size","text":"<pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.validate_filename","title":"validate_filename","text":"<pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/core/base/","title":"Base Module","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/core/base/#textxtract.core.base-classes","title":"Classes","text":""},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler","title":"FileTypeHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler-functions","title":"Functions","text":""},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler.extract","title":"extract  <code>abstractmethod</code>","text":"<pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler.extract_async","title":"extract_async  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.TextExtractor","title":"TextExtractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.TextExtractor-functions","title":"Functions","text":""},{"location":"reference/core/base/#textxtract.core.base.TextExtractor.extract","title":"extract  <code>abstractmethod</code>","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"Extract text synchronously from file path or bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/config/","title":"Config Module","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/core/config/#textxtract.core.config-classes","title":"Classes","text":""},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig-attributes","title":"Attributes","text":""},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.custom_handlers","title":"custom_handlers  <code>instance-attribute</code>","text":"<pre><code>custom_handlers = custom_handlers or {}\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.encoding","title":"encoding  <code>instance-attribute</code>","text":"<pre><code>encoding = _validate_encoding(encoding)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.extra_config","title":"extra_config  <code>instance-attribute</code>","text":"<pre><code>extra_config = kwargs\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.logging_format","title":"logging_format  <code>instance-attribute</code>","text":"<pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.logging_level","title":"logging_level  <code>instance-attribute</code>","text":"<pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.max_file_size","title":"max_file_size  <code>instance-attribute</code>","text":"<pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.max_memory_usage","title":"max_memory_usage  <code>instance-attribute</code>","text":"<pre><code>max_memory_usage = max_memory_usage\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig-functions","title":"Functions","text":""},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.__init__","title":"__init__","text":"<pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.get_handler","title":"get_handler","text":"<pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.get_handler_config","title":"get_handler_config","text":"<pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.register_handler","title":"register_handler","text":"<pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/core/exceptions/","title":"Exceptions Module","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/core/exceptions/#textxtract.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/core/logging_config/","title":"Logging_Config Module","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/core/logging_config/#textxtract.core.logging_config-functions","title":"Functions","text":""},{"location":"reference/core/logging_config/#textxtract.core.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/core/registry/","title":"Registry Module","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/core/registry/#textxtract.core.registry-attributes","title":"Attributes","text":""},{"location":"reference/core/registry/#textxtract.core.registry.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.registry')\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry-classes","title":"Classes","text":""},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry","title":"HandlerRegistry","text":"<p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - striprtf not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry-functions","title":"Functions","text":""},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.__new__","title":"__new__","text":"<pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.get_handler","title":"get_handler  <code>cached</code>","text":"<pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.get_supported_extensions","title":"get_supported_extensions","text":"<pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.is_supported","title":"is_supported","text":"<pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.register_handler","title":"register_handler","text":"<pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/core/utils/","title":"Utils Module","text":"<p>Utility functions for textxtract package.</p> <p>Classes:</p> Name Description <code>FileInfo</code> <p>File information data class.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/core/utils/#textxtract.core.utils-attributes","title":"Attributes","text":""},{"location":"reference/core/utils/#textxtract.core.utils.DEFAULT_MAX_FILE_SIZE","title":"DEFAULT_MAX_FILE_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.DEFAULT_MAX_TEMP_FILES","title":"DEFAULT_MAX_TEMP_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils-classes","title":"Classes","text":""},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo","title":"FileInfo  <code>dataclass</code>","text":"<p>File information data class.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>extension</code> <code>str</code> <code>filename</code> <code>str</code> <code>is_temp</code> <code>bool</code> <code>size_bytes</code> <code>int</code> <code>size_kb</code> <code>float</code> <p>File size in KB.</p> <code>size_mb</code> <code>float</code> Source code in <code>textxtract/core/utils.py</code> <pre><code>@dataclass\nclass FileInfo:\n    \"\"\"File information data class.\"\"\"\n\n    filename: str\n    size_bytes: int\n    size_mb: float\n    extension: str\n    is_temp: bool = False\n\n    @property\n    def size_kb(self) -&gt; float:\n        \"\"\"File size in KB.\"\"\"\n        return round(self.size_bytes / 1024, 2)\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo-attributes","title":"Attributes","text":""},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.extension","title":"extension  <code>instance-attribute</code>","text":"<pre><code>extension\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.filename","title":"filename  <code>instance-attribute</code>","text":"<pre><code>filename\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.is_temp","title":"is_temp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_temp = False\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.size_bytes","title":"size_bytes  <code>instance-attribute</code>","text":"<pre><code>size_bytes\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.size_kb","title":"size_kb  <code>property</code>","text":"<pre><code>size_kb\n</code></pre> <p>File size in KB.</p>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.size_mb","title":"size_mb  <code>instance-attribute</code>","text":"<pre><code>size_mb\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo-functions","title":"Functions","text":""},{"location":"reference/core/utils/#textxtract.core.utils.FileInfo.__init__","title":"__init__","text":"<pre><code>__init__(filename, size_bytes, size_mb, extension, is_temp=False)\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils-functions","title":"Functions","text":""},{"location":"reference/core/utils/#textxtract.core.utils.create_temp_file","title":"create_temp_file","text":"<pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.get_file_info","title":"get_file_info","text":"<pre><code>get_file_info(source, filename=None)\n</code></pre> <p>Get file information for logging and debugging.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FileInfo</code> <code>FileInfo</code> <p>Data class with file information</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(\n    source: Union[Path, str, bytes], filename: Optional[str] = None\n) -&gt; FileInfo:\n    \"\"\"\n    Get file information for logging and debugging.\n\n    Args:\n        source: File path or file bytes\n        filename: Required if source is bytes, optional for file paths\n\n    Returns:\n        FileInfo: Data class with file information\n    \"\"\"\n    if isinstance(source, bytes):\n        if not filename:\n            raise ValueError(\"filename is required when source is bytes\")\n        return FileInfo(\n            filename=filename,\n            size_bytes=len(source),\n            size_mb=round(len(source) / (1024 * 1024), 2),\n            extension=Path(filename).suffix.lower(),\n            is_temp=True,\n        )\n    else:\n        # Handle file path\n        file_path = Path(source)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n        if not file_path.is_file():\n            raise ValueError(f\"Path is not a file: {file_path}\")\n\n        file_size = file_path.stat().st_size\n        return FileInfo(\n            filename=filename or file_path.name,\n            size_bytes=file_size,\n            size_mb=round(file_size / (1024 * 1024), 2),\n            extension=file_path.suffix.lower(),\n            is_temp=False,\n        )\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.get_file_info(source)","title":"<code>source</code>","text":""},{"location":"reference/core/utils/#textxtract.core.utils.get_file_info(filename)","title":"<code>filename</code>","text":""},{"location":"reference/core/utils/#textxtract.core.utils.safe_unlink","title":"safe_unlink","text":"<pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.validate_file_extension","title":"validate_file_extension","text":"<pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.validate_file_size","title":"validate_file_size","text":"<pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.validate_filename","title":"validate_filename","text":"<pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/handlers/","title":"Handlers Module","text":""},{"location":"reference/handlers/#overview","title":"Overview","text":"<p>File format handlers for different document types.</p> <ul> <li>CSV Handler - CSV file format handler</li> <li>DOC Handler - DOC file format handler</li> <li>DOCX Handler - DOCX file format handler</li> <li>HTML Handler - HTML file format handler</li> <li>JSON Handler - JSON file format handler</li> <li>MD Handler - MD file format handler</li> <li>PDF Handler - PDF file format handler</li> <li>RTF Handler - RTF file format handler</li> <li>TXT Handler - TXT file format handler</li> <li>XML Handler - XML file format handler</li> <li>ZIP Handler - ZIP file format handler</li> </ul> <p>File type-specific handlers package.</p> <p>Modules:</p> Name Description <code>csv</code> <p>CSV file handler for text extraction.</p> <code>doc</code> <p>DOC file handler for text extraction.</p> <code>docx</code> <p>DOCX file handler for comprehensive text extraction.</p> <code>html</code> <p>HTML file handler for text extraction.</p> <code>json</code> <p>JSON file handler for text extraction.</p> <code>md</code> <p>Markdown (.md) file handler for text extraction.</p> <code>pdf</code> <p>PDF file handler for text extraction.</p> <code>rtf</code> <p>RTF file handler for text extraction.</p> <code>txt</code> <p>TXT file handler for text extraction.</p> <code>xml</code> <p>XML file handler for text extraction.</p> <code>zip</code> <p>ZIP file handler for text extraction.</p>"},{"location":"reference/handlers/#textxtract.handlers-modules","title":"Modules","text":""},{"location":"reference/handlers/#textxtract.handlers.csv","title":"csv","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/handlers/#textxtract.handlers.csv-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.csv.CSVHandler","title":"CSVHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.csv.CSVHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.doc","title":"doc","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/handlers/#textxtract.handlers.doc-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.doc.DOCHandler","title":"DOCHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            # Check if the error is due to missing libreoffice dependency\n            if (\n                \"libreoffice\" in error_msg.lower()\n                or \"no such file or directory\" in error_msg.lower()\n            ):\n                # Trigger fallback by raising FileNotFoundError\n                raise FileNotFoundError(\n                    \"antiword requires libreoffice which is not available\"\n                )\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self,\n        file_path: Path,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.doc.DOCHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.docx","title":"docx","text":"<p>DOCX file handler for comprehensive text extraction.</p> <p>This handler extracts text from: - Document paragraphs - Tables and cells - Headers and footers - Text boxes and shapes - Footnotes and endnotes (if available)</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p>"},{"location":"reference/handlers/#textxtract.handlers.docx-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.docx.DOCXHandler","title":"DOCXHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p> <pre><code>This handler provides complete text extraction from Microsoft Word documents,\nincluding all document elements such as paragraphs, tables, headers, footers,\ntext boxes, and footnotes. It's designed to handle complex document layouts\ncommonly found in resumes, reports, and structured documents.\n\nFeatures:\n    - Extracts text from document body paragraphs\n    - Processes table content with cell-by-cell extraction\n    - Captures header and footer text from all sections\n    - Attempts to extract text from embedded text boxes and shapes\n    - Handles footnotes and endnotes when available\n    - Deduplicates repeated content\n    - Cleans and normalizes extracted text\n\nExample:\n    &gt;&gt;&gt; handler = DOCXHandler()\n    &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n    &gt;&gt;&gt; print(text)\n    \"Document title\n</code></pre> <p>Paragraph content... Table data | Column 2...\"</p> <pre><code>    &gt;&gt;&gt; # Async extraction\n    &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n</code></pre> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text from a DOCX file with comprehensive content capture.</p> <code>extract_async</code> <p>Asynchronously extract text from a DOCX file.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Enhanced handler for comprehensive text extraction from DOCX files.\n\n    This handler provides complete text extraction from Microsoft Word documents,\n    including all document elements such as paragraphs, tables, headers, footers,\n    text boxes, and footnotes. It's designed to handle complex document layouts\n    commonly found in resumes, reports, and structured documents.\n\n    Features:\n        - Extracts text from document body paragraphs\n        - Processes table content with cell-by-cell extraction\n        - Captures header and footer text from all sections\n        - Attempts to extract text from embedded text boxes and shapes\n        - Handles footnotes and endnotes when available\n        - Deduplicates repeated content\n        - Cleans and normalizes extracted text\n\n    Example:\n        &gt;&gt;&gt; handler = DOCXHandler()\n        &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n        &gt;&gt;&gt; print(text)\n        \"Document title\\nParagraph content...\\nTable data | Column 2...\"\n\n        &gt;&gt;&gt; # Async extraction\n        &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n    \"\"\"\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"Clean and normalize extracted text.\n\n        Performs various text cleaning operations to improve readability\n        and consistency of extracted content.\n\n        Args:\n            text (str): Raw text to be cleaned.\n\n        Returns:\n            str: Cleaned and normalized text with proper spacing and formatting.\n\n        Note:\n            - Normalizes multiple whitespace characters to single spaces\n            - Removes excessive consecutive dots/periods\n            - Fixes spacing around punctuation marks\n            - Strips leading and trailing whitespace\n        \"\"\"\n        if not text:\n            return \"\"\n\n        # Normalize whitespace (replace multiple spaces, tabs, newlines with single space)\n        text = re.sub(r'\\s+', ' ', text)\n        # Remove excessive dots/periods (likely formatting artifacts)\n        text = re.sub(r'\\.{2,}', ' ', text)\n        # Clean up spacing around punctuation (remove spaces before punctuation)\n        text = re.sub(r'\\s+([.!?,:;])', r'\\1', text)\n        return text.strip()\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n        Performs thorough text extraction from all available document elements\n        including body text, tables, headers, footers, and embedded content.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            - Text is deduplicated to avoid repeated content from overlapping elements\n            - Table content is formatted with pipe separators between columns\n            - Special content (footnotes, text boxes) is labeled with descriptive tags\n            - Sentence breaks are automatically inserted for better readability\n        \"\"\"\n        try:\n            from docx import Document\n            import re\n\n            # Load the document\n            doc = Document(file_path)\n            text_parts = []\n            processed_text = set()  # Track processed text to avoid duplicates\n\n            # Extract text from main document paragraphs\n            for paragraph in doc.paragraphs:\n                text = paragraph.text.strip()\n                if text and text not in processed_text:\n                    text_parts.append(text)\n                    processed_text.add(text)\n\n            # Extract text from all tables in the document\n            for table in doc.tables:\n                table_texts = []\n                for row in table.rows:\n                    row_text = []\n                    for cell in row.cells:\n                        # Process each paragraph within the cell\n                        cell_paragraphs = []\n                        for paragraph in cell.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                cell_paragraphs.append(text)\n                                processed_text.add(text)\n                        if cell_paragraphs:\n                            row_text.append(\" \".join(cell_paragraphs))\n                    if row_text:\n                        # Join cell contents with pipe separator for table structure\n                        table_texts.append(\" | \".join(row_text))\n\n                # Add table content to main text collection\n                if table_texts:\n                    text_parts.extend(table_texts)\n\n            # Extract text from headers and footers across all document sections\n            for section in doc.sections:\n                # Process header content\n                if section.header:\n                    for paragraph in section.header.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n                # Process footer content\n                if section.footer:\n                    for paragraph in section.footer.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n            # Attempt to extract footnotes and endnotes (may not be available in all documents)\n            try:\n                # Extract footnotes if present\n                if hasattr(doc, 'footnotes'):\n                    for footnote in doc.footnotes:\n                        for paragraph in footnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Footnote: {text}]\")\n                                processed_text.add(text)\n\n                # Extract endnotes if present\n                if hasattr(doc, 'endnotes'):\n                    for endnote in doc.endnotes:\n                        for paragraph in endnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Endnote: {text}]\")\n                                processed_text.add(text)\n            except Exception:\n                # Footnote/endnote extraction is optional - continue if it fails\n                pass\n\n            # Attempt to extract text from embedded text boxes and shapes using XML parsing\n            try:\n                from docx.oxml.ns import qn\n\n                # Iterate through document XML elements to find drawing content\n                for element in doc.element.body.iter():\n                    if element.tag.endswith('}txbxContent'):\n                        # Extract text from text box elements\n                        for para in element.iter():\n                            if para.tag.endswith('}t') and para.text:\n                                text = para.text.strip()\n                                if text and text not in processed_text:\n                                    text_parts.append(f\"[TextBox: {text}]\")\n                                    processed_text.add(text)\n            except Exception:\n                # Text box extraction is optional - continue if it fails\n                pass\n\n            # Process and format the final output\n            if text_parts:\n                # Clean each text part and filter out empty content\n                cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n                result = \"\\n\".join(cleaned_parts)\n\n                # Add proper sentence breaks for improved readability\n                result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n                return result.strip()\n\n            return \"\"\n\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Asynchronously extract text from a DOCX file.\n\n        Provides non-blocking text extraction by running the synchronous\n        extraction method in a separate thread.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            This method uses asyncio.to_thread() to run the synchronous extraction\n            in a thread pool, making it suitable for async/await usage patterns.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.docx.DOCXHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text from a DOCX file with comprehensive content capture.</p> <p>Performs thorough text extraction from all available document elements including body text, tables, headers, footers, and embedded content.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>config</code> <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <ul> <li>Text is deduplicated to avoid repeated content from overlapping elements</li> <li>Table content is formatted with pipe separators between columns</li> <li>Special content (footnotes, text boxes) is labeled with descriptive tags</li> <li>Sentence breaks are automatically inserted for better readability</li> </ul> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n    Performs thorough text extraction from all available document elements\n    including body text, tables, headers, footers, and embedded content.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        - Text is deduplicated to avoid repeated content from overlapping elements\n        - Table content is formatted with pipe separators between columns\n        - Special content (footnotes, text boxes) is labeled with descriptive tags\n        - Sentence breaks are automatically inserted for better readability\n    \"\"\"\n    try:\n        from docx import Document\n        import re\n\n        # Load the document\n        doc = Document(file_path)\n        text_parts = []\n        processed_text = set()  # Track processed text to avoid duplicates\n\n        # Extract text from main document paragraphs\n        for paragraph in doc.paragraphs:\n            text = paragraph.text.strip()\n            if text and text not in processed_text:\n                text_parts.append(text)\n                processed_text.add(text)\n\n        # Extract text from all tables in the document\n        for table in doc.tables:\n            table_texts = []\n            for row in table.rows:\n                row_text = []\n                for cell in row.cells:\n                    # Process each paragraph within the cell\n                    cell_paragraphs = []\n                    for paragraph in cell.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            cell_paragraphs.append(text)\n                            processed_text.add(text)\n                    if cell_paragraphs:\n                        row_text.append(\" \".join(cell_paragraphs))\n                if row_text:\n                    # Join cell contents with pipe separator for table structure\n                    table_texts.append(\" | \".join(row_text))\n\n            # Add table content to main text collection\n            if table_texts:\n                text_parts.extend(table_texts)\n\n        # Extract text from headers and footers across all document sections\n        for section in doc.sections:\n            # Process header content\n            if section.header:\n                for paragraph in section.header.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n            # Process footer content\n            if section.footer:\n                for paragraph in section.footer.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n        # Attempt to extract footnotes and endnotes (may not be available in all documents)\n        try:\n            # Extract footnotes if present\n            if hasattr(doc, 'footnotes'):\n                for footnote in doc.footnotes:\n                    for paragraph in footnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Footnote: {text}]\")\n                            processed_text.add(text)\n\n            # Extract endnotes if present\n            if hasattr(doc, 'endnotes'):\n                for endnote in doc.endnotes:\n                    for paragraph in endnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Endnote: {text}]\")\n                            processed_text.add(text)\n        except Exception:\n            # Footnote/endnote extraction is optional - continue if it fails\n            pass\n\n        # Attempt to extract text from embedded text boxes and shapes using XML parsing\n        try:\n            from docx.oxml.ns import qn\n\n            # Iterate through document XML elements to find drawing content\n            for element in doc.element.body.iter():\n                if element.tag.endswith('}txbxContent'):\n                    # Extract text from text box elements\n                    for para in element.iter():\n                        if para.tag.endswith('}t') and para.text:\n                            text = para.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[TextBox: {text}]\")\n                                processed_text.add(text)\n        except Exception:\n            # Text box extraction is optional - continue if it fails\n            pass\n\n        # Process and format the final output\n        if text_parts:\n            # Clean each text part and filter out empty content\n            cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n            result = \"\\n\".join(cleaned_parts)\n\n            # Add proper sentence breaks for improved readability\n            result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n            return result.strip()\n\n        return \"\"\n\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Asynchronously extract text from a DOCX file.</p> <p>Provides non-blocking text extraction by running the synchronous extraction method in a separate thread.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>config</code> <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <p>This method uses asyncio.to_thread() to run the synchronous extraction in a thread pool, making it suitable for async/await usage patterns.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Asynchronously extract text from a DOCX file.\n\n    Provides non-blocking text extraction by running the synchronous\n    extraction method in a separate thread.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        This method uses asyncio.to_thread() to run the synchronous extraction\n        in a thread pool, making it suitable for async/await usage patterns.\n    \"\"\"\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.html","title":"html","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/handlers/#textxtract.handlers.html-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.html.HTMLHandler","title":"HTMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.html.HTMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.json","title":"json","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/handlers/#textxtract.handlers.json-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.json.JSONHandler","title":"JSONHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.json.JSONHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.md","title":"md","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/handlers/#textxtract.handlers.md-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.md.MDHandler","title":"MDHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.md.MDHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.pdf","title":"pdf","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/handlers/#textxtract.handlers.pdf-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.pdf.PDFHandler","title":"PDFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.pdf.PDFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.rtf","title":"rtf","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/handlers/#textxtract.handlers.rtf-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.rtf.RTFHandler","title":"RTFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.rtf.RTFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.txt","title":"txt","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/handlers/#textxtract.handlers.txt-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.txt.TXTHandler","title":"TXTHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.txt.TXTHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.xml","title":"xml","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/handlers/#textxtract.handlers.xml-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.xml.XMLHandler","title":"XMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.xml.XMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip","title":"zip","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/handlers/#textxtract.handlers.zip-attributes","title":"Attributes","text":""},{"location":"reference/handlers/#textxtract.handlers.zip.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.zip.ZIPHandler","title":"ZIPHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip.ZIPHandler-attributes","title":"Attributes","text":"MAX_EXTRACT_SIZE <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre> <code></code> MAX_FILES <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_FILES = 1000\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip.ZIPHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/","title":"Handlers Module","text":"<p>File type-specific handlers package.</p> <p>Modules:</p> Name Description <code>csv</code> <p>CSV file handler for text extraction.</p> <code>doc</code> <p>DOC file handler for text extraction.</p> <code>docx</code> <p>DOCX file handler for comprehensive text extraction.</p> <code>html</code> <p>HTML file handler for text extraction.</p> <code>json</code> <p>JSON file handler for text extraction.</p> <code>md</code> <p>Markdown (.md) file handler for text extraction.</p> <code>pdf</code> <p>PDF file handler for text extraction.</p> <code>rtf</code> <p>RTF file handler for text extraction.</p> <code>txt</code> <p>TXT file handler for text extraction.</p> <code>xml</code> <p>XML file handler for text extraction.</p> <code>zip</code> <p>ZIP file handler for text extraction.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers-modules","title":"Modules","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.csv","title":"csv","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.csv-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.csv.CSVHandler","title":"CSVHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.csv.CSVHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.doc","title":"doc","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.doc-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.doc.DOCHandler","title":"DOCHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            # Check if the error is due to missing libreoffice dependency\n            if (\n                \"libreoffice\" in error_msg.lower()\n                or \"no such file or directory\" in error_msg.lower()\n            ):\n                # Trigger fallback by raising FileNotFoundError\n                raise FileNotFoundError(\n                    \"antiword requires libreoffice which is not available\"\n                )\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self,\n        file_path: Path,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.doc.DOCHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.docx","title":"docx","text":"<p>DOCX file handler for comprehensive text extraction.</p> <p>This handler extracts text from: - Document paragraphs - Tables and cells - Headers and footers - Text boxes and shapes - Footnotes and endnotes (if available)</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.docx-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.docx.DOCXHandler","title":"DOCXHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p> <pre><code>This handler provides complete text extraction from Microsoft Word documents,\nincluding all document elements such as paragraphs, tables, headers, footers,\ntext boxes, and footnotes. It's designed to handle complex document layouts\ncommonly found in resumes, reports, and structured documents.\n\nFeatures:\n    - Extracts text from document body paragraphs\n    - Processes table content with cell-by-cell extraction\n    - Captures header and footer text from all sections\n    - Attempts to extract text from embedded text boxes and shapes\n    - Handles footnotes and endnotes when available\n    - Deduplicates repeated content\n    - Cleans and normalizes extracted text\n\nExample:\n    &gt;&gt;&gt; handler = DOCXHandler()\n    &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n    &gt;&gt;&gt; print(text)\n    \"Document title\n</code></pre> <p>Paragraph content... Table data | Column 2...\"</p> <pre><code>    &gt;&gt;&gt; # Async extraction\n    &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n</code></pre> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text from a DOCX file with comprehensive content capture.</p> <code>extract_async</code> <p>Asynchronously extract text from a DOCX file.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Enhanced handler for comprehensive text extraction from DOCX files.\n\n    This handler provides complete text extraction from Microsoft Word documents,\n    including all document elements such as paragraphs, tables, headers, footers,\n    text boxes, and footnotes. It's designed to handle complex document layouts\n    commonly found in resumes, reports, and structured documents.\n\n    Features:\n        - Extracts text from document body paragraphs\n        - Processes table content with cell-by-cell extraction\n        - Captures header and footer text from all sections\n        - Attempts to extract text from embedded text boxes and shapes\n        - Handles footnotes and endnotes when available\n        - Deduplicates repeated content\n        - Cleans and normalizes extracted text\n\n    Example:\n        &gt;&gt;&gt; handler = DOCXHandler()\n        &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n        &gt;&gt;&gt; print(text)\n        \"Document title\\nParagraph content...\\nTable data | Column 2...\"\n\n        &gt;&gt;&gt; # Async extraction\n        &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n    \"\"\"\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"Clean and normalize extracted text.\n\n        Performs various text cleaning operations to improve readability\n        and consistency of extracted content.\n\n        Args:\n            text (str): Raw text to be cleaned.\n\n        Returns:\n            str: Cleaned and normalized text with proper spacing and formatting.\n\n        Note:\n            - Normalizes multiple whitespace characters to single spaces\n            - Removes excessive consecutive dots/periods\n            - Fixes spacing around punctuation marks\n            - Strips leading and trailing whitespace\n        \"\"\"\n        if not text:\n            return \"\"\n\n        # Normalize whitespace (replace multiple spaces, tabs, newlines with single space)\n        text = re.sub(r'\\s+', ' ', text)\n        # Remove excessive dots/periods (likely formatting artifacts)\n        text = re.sub(r'\\.{2,}', ' ', text)\n        # Clean up spacing around punctuation (remove spaces before punctuation)\n        text = re.sub(r'\\s+([.!?,:;])', r'\\1', text)\n        return text.strip()\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n        Performs thorough text extraction from all available document elements\n        including body text, tables, headers, footers, and embedded content.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            - Text is deduplicated to avoid repeated content from overlapping elements\n            - Table content is formatted with pipe separators between columns\n            - Special content (footnotes, text boxes) is labeled with descriptive tags\n            - Sentence breaks are automatically inserted for better readability\n        \"\"\"\n        try:\n            from docx import Document\n            import re\n\n            # Load the document\n            doc = Document(file_path)\n            text_parts = []\n            processed_text = set()  # Track processed text to avoid duplicates\n\n            # Extract text from main document paragraphs\n            for paragraph in doc.paragraphs:\n                text = paragraph.text.strip()\n                if text and text not in processed_text:\n                    text_parts.append(text)\n                    processed_text.add(text)\n\n            # Extract text from all tables in the document\n            for table in doc.tables:\n                table_texts = []\n                for row in table.rows:\n                    row_text = []\n                    for cell in row.cells:\n                        # Process each paragraph within the cell\n                        cell_paragraphs = []\n                        for paragraph in cell.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                cell_paragraphs.append(text)\n                                processed_text.add(text)\n                        if cell_paragraphs:\n                            row_text.append(\" \".join(cell_paragraphs))\n                    if row_text:\n                        # Join cell contents with pipe separator for table structure\n                        table_texts.append(\" | \".join(row_text))\n\n                # Add table content to main text collection\n                if table_texts:\n                    text_parts.extend(table_texts)\n\n            # Extract text from headers and footers across all document sections\n            for section in doc.sections:\n                # Process header content\n                if section.header:\n                    for paragraph in section.header.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n                # Process footer content\n                if section.footer:\n                    for paragraph in section.footer.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n            # Attempt to extract footnotes and endnotes (may not be available in all documents)\n            try:\n                # Extract footnotes if present\n                if hasattr(doc, 'footnotes'):\n                    for footnote in doc.footnotes:\n                        for paragraph in footnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Footnote: {text}]\")\n                                processed_text.add(text)\n\n                # Extract endnotes if present\n                if hasattr(doc, 'endnotes'):\n                    for endnote in doc.endnotes:\n                        for paragraph in endnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Endnote: {text}]\")\n                                processed_text.add(text)\n            except Exception:\n                # Footnote/endnote extraction is optional - continue if it fails\n                pass\n\n            # Attempt to extract text from embedded text boxes and shapes using XML parsing\n            try:\n                from docx.oxml.ns import qn\n\n                # Iterate through document XML elements to find drawing content\n                for element in doc.element.body.iter():\n                    if element.tag.endswith('}txbxContent'):\n                        # Extract text from text box elements\n                        for para in element.iter():\n                            if para.tag.endswith('}t') and para.text:\n                                text = para.text.strip()\n                                if text and text not in processed_text:\n                                    text_parts.append(f\"[TextBox: {text}]\")\n                                    processed_text.add(text)\n            except Exception:\n                # Text box extraction is optional - continue if it fails\n                pass\n\n            # Process and format the final output\n            if text_parts:\n                # Clean each text part and filter out empty content\n                cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n                result = \"\\n\".join(cleaned_parts)\n\n                # Add proper sentence breaks for improved readability\n                result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n                return result.strip()\n\n            return \"\"\n\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Asynchronously extract text from a DOCX file.\n\n        Provides non-blocking text extraction by running the synchronous\n        extraction method in a separate thread.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            This method uses asyncio.to_thread() to run the synchronous extraction\n            in a thread pool, making it suitable for async/await usage patterns.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.docx.DOCXHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text from a DOCX file with comprehensive content capture.</p> <p>Performs thorough text extraction from all available document elements including body text, tables, headers, footers, and embedded content.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>config</code> <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <ul> <li>Text is deduplicated to avoid repeated content from overlapping elements</li> <li>Table content is formatted with pipe separators between columns</li> <li>Special content (footnotes, text boxes) is labeled with descriptive tags</li> <li>Sentence breaks are automatically inserted for better readability</li> </ul> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n    Performs thorough text extraction from all available document elements\n    including body text, tables, headers, footers, and embedded content.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        - Text is deduplicated to avoid repeated content from overlapping elements\n        - Table content is formatted with pipe separators between columns\n        - Special content (footnotes, text boxes) is labeled with descriptive tags\n        - Sentence breaks are automatically inserted for better readability\n    \"\"\"\n    try:\n        from docx import Document\n        import re\n\n        # Load the document\n        doc = Document(file_path)\n        text_parts = []\n        processed_text = set()  # Track processed text to avoid duplicates\n\n        # Extract text from main document paragraphs\n        for paragraph in doc.paragraphs:\n            text = paragraph.text.strip()\n            if text and text not in processed_text:\n                text_parts.append(text)\n                processed_text.add(text)\n\n        # Extract text from all tables in the document\n        for table in doc.tables:\n            table_texts = []\n            for row in table.rows:\n                row_text = []\n                for cell in row.cells:\n                    # Process each paragraph within the cell\n                    cell_paragraphs = []\n                    for paragraph in cell.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            cell_paragraphs.append(text)\n                            processed_text.add(text)\n                    if cell_paragraphs:\n                        row_text.append(\" \".join(cell_paragraphs))\n                if row_text:\n                    # Join cell contents with pipe separator for table structure\n                    table_texts.append(\" | \".join(row_text))\n\n            # Add table content to main text collection\n            if table_texts:\n                text_parts.extend(table_texts)\n\n        # Extract text from headers and footers across all document sections\n        for section in doc.sections:\n            # Process header content\n            if section.header:\n                for paragraph in section.header.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n            # Process footer content\n            if section.footer:\n                for paragraph in section.footer.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n        # Attempt to extract footnotes and endnotes (may not be available in all documents)\n        try:\n            # Extract footnotes if present\n            if hasattr(doc, 'footnotes'):\n                for footnote in doc.footnotes:\n                    for paragraph in footnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Footnote: {text}]\")\n                            processed_text.add(text)\n\n            # Extract endnotes if present\n            if hasattr(doc, 'endnotes'):\n                for endnote in doc.endnotes:\n                    for paragraph in endnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Endnote: {text}]\")\n                            processed_text.add(text)\n        except Exception:\n            # Footnote/endnote extraction is optional - continue if it fails\n            pass\n\n        # Attempt to extract text from embedded text boxes and shapes using XML parsing\n        try:\n            from docx.oxml.ns import qn\n\n            # Iterate through document XML elements to find drawing content\n            for element in doc.element.body.iter():\n                if element.tag.endswith('}txbxContent'):\n                    # Extract text from text box elements\n                    for para in element.iter():\n                        if para.tag.endswith('}t') and para.text:\n                            text = para.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[TextBox: {text}]\")\n                                processed_text.add(text)\n        except Exception:\n            # Text box extraction is optional - continue if it fails\n            pass\n\n        # Process and format the final output\n        if text_parts:\n            # Clean each text part and filter out empty content\n            cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n            result = \"\\n\".join(cleaned_parts)\n\n            # Add proper sentence breaks for improved readability\n            result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n            return result.strip()\n\n        return \"\"\n\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Asynchronously extract text from a DOCX file.</p> <p>Provides non-blocking text extraction by running the synchronous extraction method in a separate thread.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>config</code> <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <p>This method uses asyncio.to_thread() to run the synchronous extraction in a thread pool, making it suitable for async/await usage patterns.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Asynchronously extract text from a DOCX file.\n\n    Provides non-blocking text extraction by running the synchronous\n    extraction method in a separate thread.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        This method uses asyncio.to_thread() to run the synchronous extraction\n        in a thread pool, making it suitable for async/await usage patterns.\n    \"\"\"\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.html","title":"html","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.html-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.html.HTMLHandler","title":"HTMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.html.HTMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.json","title":"json","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.json-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.json.JSONHandler","title":"JSONHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.json.JSONHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.md","title":"md","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.md-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.md.MDHandler","title":"MDHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.md.MDHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf","title":"pdf","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf.PDFHandler","title":"PDFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf.PDFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf","title":"rtf","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf.RTFHandler","title":"RTFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf.RTFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.txt","title":"txt","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.txt-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.txt.TXTHandler","title":"TXTHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.txt.TXTHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.xml","title":"xml","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.xml-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.xml.XMLHandler","title":"XMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.xml.XMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip","title":"zip","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip-attributes","title":"Attributes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.ZIPHandler","title":"ZIPHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.ZIPHandler-attributes","title":"Attributes","text":"MAX_EXTRACT_SIZE <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre> <code></code> MAX_FILES <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_FILES = 1000\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.ZIPHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/csv/","title":"Csv Module","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/handlers/csv/#textxtract.handlers.csv-classes","title":"Classes","text":""},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler","title":"CSVHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/doc/","title":"Doc Module","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/handlers/doc/#textxtract.handlers.doc-classes","title":"Classes","text":""},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler","title":"DOCHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            # Check if the error is due to missing libreoffice dependency\n            if (\n                \"libreoffice\" in error_msg.lower()\n                or \"no such file or directory\" in error_msg.lower()\n            ):\n                # Trigger fallback by raising FileNotFoundError\n                raise FileNotFoundError(\n                    \"antiword requires libreoffice which is not available\"\n                )\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self,\n        file_path: Path,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/docx/","title":"Docx Module","text":"<p>DOCX file handler for comprehensive text extraction.</p> <p>This handler extracts text from: - Document paragraphs - Tables and cells - Headers and footers - Text boxes and shapes - Footnotes and endnotes (if available)</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx-classes","title":"Classes","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler","title":"DOCXHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Enhanced handler for comprehensive text extraction from DOCX files.</p> <pre><code>This handler provides complete text extraction from Microsoft Word documents,\nincluding all document elements such as paragraphs, tables, headers, footers,\ntext boxes, and footnotes. It's designed to handle complex document layouts\ncommonly found in resumes, reports, and structured documents.\n\nFeatures:\n    - Extracts text from document body paragraphs\n    - Processes table content with cell-by-cell extraction\n    - Captures header and footer text from all sections\n    - Attempts to extract text from embedded text boxes and shapes\n    - Handles footnotes and endnotes when available\n    - Deduplicates repeated content\n    - Cleans and normalizes extracted text\n\nExample:\n    &gt;&gt;&gt; handler = DOCXHandler()\n    &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n    &gt;&gt;&gt; print(text)\n    \"Document title\n</code></pre> <p>Paragraph content... Table data | Column 2...\"</p> <pre><code>    &gt;&gt;&gt; # Async extraction\n    &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n</code></pre> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text from a DOCX file with comprehensive content capture.</p> <code>extract_async</code> <p>Asynchronously extract text from a DOCX file.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Enhanced handler for comprehensive text extraction from DOCX files.\n\n    This handler provides complete text extraction from Microsoft Word documents,\n    including all document elements such as paragraphs, tables, headers, footers,\n    text boxes, and footnotes. It's designed to handle complex document layouts\n    commonly found in resumes, reports, and structured documents.\n\n    Features:\n        - Extracts text from document body paragraphs\n        - Processes table content with cell-by-cell extraction\n        - Captures header and footer text from all sections\n        - Attempts to extract text from embedded text boxes and shapes\n        - Handles footnotes and endnotes when available\n        - Deduplicates repeated content\n        - Cleans and normalizes extracted text\n\n    Example:\n        &gt;&gt;&gt; handler = DOCXHandler()\n        &gt;&gt;&gt; text = handler.extract(Path(\"document.docx\"))\n        &gt;&gt;&gt; print(text)\n        \"Document title\\nParagraph content...\\nTable data | Column 2...\"\n\n        &gt;&gt;&gt; # Async extraction\n        &gt;&gt;&gt; text = await handler.extract_async(Path(\"document.docx\"))\n    \"\"\"\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"Clean and normalize extracted text.\n\n        Performs various text cleaning operations to improve readability\n        and consistency of extracted content.\n\n        Args:\n            text (str): Raw text to be cleaned.\n\n        Returns:\n            str: Cleaned and normalized text with proper spacing and formatting.\n\n        Note:\n            - Normalizes multiple whitespace characters to single spaces\n            - Removes excessive consecutive dots/periods\n            - Fixes spacing around punctuation marks\n            - Strips leading and trailing whitespace\n        \"\"\"\n        if not text:\n            return \"\"\n\n        # Normalize whitespace (replace multiple spaces, tabs, newlines with single space)\n        text = re.sub(r'\\s+', ' ', text)\n        # Remove excessive dots/periods (likely formatting artifacts)\n        text = re.sub(r'\\.{2,}', ' ', text)\n        # Clean up spacing around punctuation (remove spaces before punctuation)\n        text = re.sub(r'\\s+([.!?,:;])', r'\\1', text)\n        return text.strip()\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n        Performs thorough text extraction from all available document elements\n        including body text, tables, headers, footers, and embedded content.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            - Text is deduplicated to avoid repeated content from overlapping elements\n            - Table content is formatted with pipe separators between columns\n            - Special content (footnotes, text boxes) is labeled with descriptive tags\n            - Sentence breaks are automatically inserted for better readability\n        \"\"\"\n        try:\n            from docx import Document\n            import re\n\n            # Load the document\n            doc = Document(file_path)\n            text_parts = []\n            processed_text = set()  # Track processed text to avoid duplicates\n\n            # Extract text from main document paragraphs\n            for paragraph in doc.paragraphs:\n                text = paragraph.text.strip()\n                if text and text not in processed_text:\n                    text_parts.append(text)\n                    processed_text.add(text)\n\n            # Extract text from all tables in the document\n            for table in doc.tables:\n                table_texts = []\n                for row in table.rows:\n                    row_text = []\n                    for cell in row.cells:\n                        # Process each paragraph within the cell\n                        cell_paragraphs = []\n                        for paragraph in cell.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                cell_paragraphs.append(text)\n                                processed_text.add(text)\n                        if cell_paragraphs:\n                            row_text.append(\" \".join(cell_paragraphs))\n                    if row_text:\n                        # Join cell contents with pipe separator for table structure\n                        table_texts.append(\" | \".join(row_text))\n\n                # Add table content to main text collection\n                if table_texts:\n                    text_parts.extend(table_texts)\n\n            # Extract text from headers and footers across all document sections\n            for section in doc.sections:\n                # Process header content\n                if section.header:\n                    for paragraph in section.header.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n                # Process footer content\n                if section.footer:\n                    for paragraph in section.footer.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(text)\n                            processed_text.add(text)\n\n            # Attempt to extract footnotes and endnotes (may not be available in all documents)\n            try:\n                # Extract footnotes if present\n                if hasattr(doc, 'footnotes'):\n                    for footnote in doc.footnotes:\n                        for paragraph in footnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Footnote: {text}]\")\n                                processed_text.add(text)\n\n                # Extract endnotes if present\n                if hasattr(doc, 'endnotes'):\n                    for endnote in doc.endnotes:\n                        for paragraph in endnote.paragraphs:\n                            text = paragraph.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[Endnote: {text}]\")\n                                processed_text.add(text)\n            except Exception:\n                # Footnote/endnote extraction is optional - continue if it fails\n                pass\n\n            # Attempt to extract text from embedded text boxes and shapes using XML parsing\n            try:\n                from docx.oxml.ns import qn\n\n                # Iterate through document XML elements to find drawing content\n                for element in doc.element.body.iter():\n                    if element.tag.endswith('}txbxContent'):\n                        # Extract text from text box elements\n                        for para in element.iter():\n                            if para.tag.endswith('}t') and para.text:\n                                text = para.text.strip()\n                                if text and text not in processed_text:\n                                    text_parts.append(f\"[TextBox: {text}]\")\n                                    processed_text.add(text)\n            except Exception:\n                # Text box extraction is optional - continue if it fails\n                pass\n\n            # Process and format the final output\n            if text_parts:\n                # Clean each text part and filter out empty content\n                cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n                result = \"\\n\".join(cleaned_parts)\n\n                # Add proper sentence breaks for improved readability\n                result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n                return result.strip()\n\n            return \"\"\n\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Asynchronously extract text from a DOCX file.\n\n        Provides non-blocking text extraction by running the synchronous\n        extraction method in a separate thread.\n\n        Args:\n            file_path (Path): Path to the DOCX file to extract text from.\n            config (Optional[dict], optional): Configuration options for extraction.\n                Currently not used but reserved for future enhancements.\n\n        Returns:\n            str: Extracted and cleaned text from the document with proper formatting.\n                Returns empty string if no text is found.\n\n        Raises:\n            ExtractionError: If the file cannot be read or processed, or if the\n                python-docx library is not available.\n\n        Note:\n            This method uses asyncio.to_thread() to run the synchronous extraction\n            in a thread pool, making it suitable for async/await usage patterns.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text from a DOCX file with comprehensive content capture.</p> <p>Performs thorough text extraction from all available document elements including body text, tables, headers, footers, and embedded content.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <ul> <li>Text is deduplicated to avoid repeated content from overlapping elements</li> <li>Table content is formatted with pipe separators between columns</li> <li>Special content (footnotes, text boxes) is labeled with descriptive tags</li> <li>Sentence breaks are automatically inserted for better readability</li> </ul> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text from a DOCX file with comprehensive content capture.\n\n    Performs thorough text extraction from all available document elements\n    including body text, tables, headers, footers, and embedded content.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        - Text is deduplicated to avoid repeated content from overlapping elements\n        - Table content is formatted with pipe separators between columns\n        - Special content (footnotes, text boxes) is labeled with descriptive tags\n        - Sentence breaks are automatically inserted for better readability\n    \"\"\"\n    try:\n        from docx import Document\n        import re\n\n        # Load the document\n        doc = Document(file_path)\n        text_parts = []\n        processed_text = set()  # Track processed text to avoid duplicates\n\n        # Extract text from main document paragraphs\n        for paragraph in doc.paragraphs:\n            text = paragraph.text.strip()\n            if text and text not in processed_text:\n                text_parts.append(text)\n                processed_text.add(text)\n\n        # Extract text from all tables in the document\n        for table in doc.tables:\n            table_texts = []\n            for row in table.rows:\n                row_text = []\n                for cell in row.cells:\n                    # Process each paragraph within the cell\n                    cell_paragraphs = []\n                    for paragraph in cell.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            cell_paragraphs.append(text)\n                            processed_text.add(text)\n                    if cell_paragraphs:\n                        row_text.append(\" \".join(cell_paragraphs))\n                if row_text:\n                    # Join cell contents with pipe separator for table structure\n                    table_texts.append(\" | \".join(row_text))\n\n            # Add table content to main text collection\n            if table_texts:\n                text_parts.extend(table_texts)\n\n        # Extract text from headers and footers across all document sections\n        for section in doc.sections:\n            # Process header content\n            if section.header:\n                for paragraph in section.header.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n            # Process footer content\n            if section.footer:\n                for paragraph in section.footer.paragraphs:\n                    text = paragraph.text.strip()\n                    if text and text not in processed_text:\n                        text_parts.append(text)\n                        processed_text.add(text)\n\n        # Attempt to extract footnotes and endnotes (may not be available in all documents)\n        try:\n            # Extract footnotes if present\n            if hasattr(doc, 'footnotes'):\n                for footnote in doc.footnotes:\n                    for paragraph in footnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Footnote: {text}]\")\n                            processed_text.add(text)\n\n            # Extract endnotes if present\n            if hasattr(doc, 'endnotes'):\n                for endnote in doc.endnotes:\n                    for paragraph in endnote.paragraphs:\n                        text = paragraph.text.strip()\n                        if text and text not in processed_text:\n                            text_parts.append(f\"[Endnote: {text}]\")\n                            processed_text.add(text)\n        except Exception:\n            # Footnote/endnote extraction is optional - continue if it fails\n            pass\n\n        # Attempt to extract text from embedded text boxes and shapes using XML parsing\n        try:\n            from docx.oxml.ns import qn\n\n            # Iterate through document XML elements to find drawing content\n            for element in doc.element.body.iter():\n                if element.tag.endswith('}txbxContent'):\n                    # Extract text from text box elements\n                    for para in element.iter():\n                        if para.tag.endswith('}t') and para.text:\n                            text = para.text.strip()\n                            if text and text not in processed_text:\n                                text_parts.append(f\"[TextBox: {text}]\")\n                                processed_text.add(text)\n        except Exception:\n            # Text box extraction is optional - continue if it fails\n            pass\n\n        # Process and format the final output\n        if text_parts:\n            # Clean each text part and filter out empty content\n            cleaned_parts = [self._clean_text(part) for part in text_parts if part.strip()]\n            result = \"\\n\".join(cleaned_parts)\n\n            # Add proper sentence breaks for improved readability\n            result = re.sub(r'([.!?])\\s*([A-Z])', r'\\1\\n\\2', result)\n            return result.strip()\n\n        return \"\"\n\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract(file_path)","title":"<code>file_path</code>","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Asynchronously extract text from a DOCX file.</p> <p>Provides non-blocking text extraction by running the synchronous extraction method in a separate thread.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>Path to the DOCX file to extract text from.</p> required <code>Optional[dict]</code> <p>Configuration options for extraction. Currently not used but reserved for future enhancements.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted and cleaned text from the document with proper formatting. Returns empty string if no text is found.</p> <p>Raises:</p> Type Description <code>ExtractionError</code> <p>If the file cannot be read or processed, or if the python-docx library is not available.</p> Note <p>This method uses asyncio.to_thread() to run the synchronous extraction in a thread pool, making it suitable for async/await usage patterns.</p> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Asynchronously extract text from a DOCX file.\n\n    Provides non-blocking text extraction by running the synchronous\n    extraction method in a separate thread.\n\n    Args:\n        file_path (Path): Path to the DOCX file to extract text from.\n        config (Optional[dict], optional): Configuration options for extraction.\n            Currently not used but reserved for future enhancements.\n\n    Returns:\n        str: Extracted and cleaned text from the document with proper formatting.\n            Returns empty string if no text is found.\n\n    Raises:\n        ExtractionError: If the file cannot be read or processed, or if the\n            python-docx library is not available.\n\n    Note:\n        This method uses asyncio.to_thread() to run the synchronous extraction\n        in a thread pool, making it suitable for async/await usage patterns.\n    \"\"\"\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract_async(file_path)","title":"<code>file_path</code>","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract_async(config)","title":"<code>config</code>","text":""},{"location":"reference/handlers/html/","title":"Html Module","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/handlers/html/#textxtract.handlers.html-classes","title":"Classes","text":""},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler","title":"HTMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/json/","title":"Json Module","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/handlers/json/#textxtract.handlers.json-classes","title":"Classes","text":""},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler","title":"JSONHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/md/","title":"Md Module","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/handlers/md/#textxtract.handlers.md-classes","title":"Classes","text":""},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler","title":"MDHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/pdf/","title":"Pdf Module","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf-classes","title":"Classes","text":""},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler","title":"PDFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/rtf/","title":"Rtf Module","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf-classes","title":"Classes","text":""},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler","title":"RTFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/txt/","title":"Txt Module","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/handlers/txt/#textxtract.handlers.txt-classes","title":"Classes","text":""},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler","title":"TXTHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/xml/","title":"Xml Module","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/handlers/xml/#textxtract.handlers.xml-classes","title":"Classes","text":""},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler","title":"XMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/zip/","title":"Zip Module","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip-attributes","title":"Attributes","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip-classes","title":"Classes","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler","title":"ZIPHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler-attributes","title":"Attributes","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.MAX_EXTRACT_SIZE","title":"MAX_EXTRACT_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.MAX_FILES","title":"MAX_FILES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_FILES = 1000\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/sync/","title":"Sync Module","text":""},{"location":"reference/sync/#overview","title":"Overview","text":"<p>Synchronous text extraction components.</p> <p>Synchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Synchronous text extraction logic with support for file paths and bytes.</p>"},{"location":"reference/sync/#textxtract.sync-modules","title":"Modules","text":""},{"location":"reference/sync/#textxtract.sync.extractor","title":"extractor","text":"<p>Synchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/sync/#textxtract.sync.extractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/#textxtract.sync.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor-classes","title":"Classes","text":""},{"location":"reference/sync/#textxtract.sync.extractor.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with support for file paths and bytes.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file path or bytes.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text\n            try:\n                result = handler.extract(file_path, config or self.config.__dict__)\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def _prepare_file_path(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            temp_path = create_temp_file(\n                source, filename, config and config.get(\"max_file_size\")\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor.SyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor.SyncTextExtractor-functions","title":"Functions","text":"__enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre> <code></code> extract <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file path or bytes.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text\n        try:\n            result = handler.extract(file_path, config or self.config.__dict__)\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/sync/__init__/","title":"Sync Module","text":"<p>Synchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Synchronous text extraction logic with support for file paths and bytes.</p>"},{"location":"reference/sync/__init__/#textxtract.sync-modules","title":"Modules","text":""},{"location":"reference/sync/__init__/#textxtract.sync.extractor","title":"extractor","text":"<p>Synchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/__init__/#textxtract.sync.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor-classes","title":"Classes","text":""},{"location":"reference/sync/__init__/#textxtract.sync.extractor.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with support for file paths and bytes.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file path or bytes.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text\n            try:\n                result = handler.extract(file_path, config or self.config.__dict__)\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def _prepare_file_path(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            temp_path = create_temp_file(\n                source, filename, config and config.get(\"max_file_size\")\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor.SyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor.SyncTextExtractor-functions","title":"Functions","text":"__enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre> <code></code> extract <pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>filename</code> <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file path or bytes.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text\n        try:\n            result = handler.extract(file_path, config or self.config.__dict__)\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/sync/extractor/","title":"Extractor Module","text":"<p>Synchronous text extraction logic with support for file paths and bytes.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor-classes","title":"Classes","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with support for file paths and bytes.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file path or bytes.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with support for file paths and bytes.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file path or bytes.\n\n        Args:\n            source: File path (Path/str) or file bytes\n            filename: Required if source is bytes, optional for file paths\n            config: Optional configuration overrides\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            ValueError: If filename is missing when source is bytes\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        # Get file info for logging\n        file_info = get_file_info(source, filename)\n        logger.debug(\"Processing file: %s\", file_info)\n\n        # Prepare file path (create temp file if needed)\n        file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n        try:\n            # Validate file extension\n            suffix = file_info.extension\n            if not suffix:\n                raise FileTypeNotSupportedError(\n                    f\"File has no extension: {file_info.filename}\"\n                )\n\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            # Get handler\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n                handler_name,\n                file_info.filename,\n                file_info.size_mb,\n                file_info.is_temp,\n            )\n\n            # Extract text\n            try:\n                result = handler.extract(file_path, config or self.config.__dict__)\n            except Exception as e:\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    file_info.filename,\n                    handler_name,\n                    e,\n                )\n\n                # Re-raise custom extraction errors\n                if isinstance(e, ExtractionError):\n                    raise\n                # Wrap known invalid file errors\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                file_info.filename,\n                len(result),\n            )\n            return result\n\n        finally:\n            # Clean up temporary file if created\n            if temp_path:\n                safe_unlink(temp_path)\n                logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def _prepare_file_path(\n        self,\n        source: Union[Path, str, bytes],\n        filename: Optional[str],\n        config: Optional[dict],\n    ) -&gt; tuple[Path, Optional[Path]]:\n        \"\"\"\n        Prepare file path for extraction.\n\n        Returns:\n            tuple: (file_path, temp_path_if_created)\n        \"\"\"\n        if isinstance(source, bytes):\n            # Handle bytes input - create temporary file\n            if not filename:\n                raise ValueError(\"filename is required when source is bytes\")\n\n            temp_path = create_temp_file(\n                source, filename, config and config.get(\"max_file_size\")\n            )\n            logger.debug(\n                \"Temporary file created at %s for filename %s\", temp_path, filename\n            )\n            return temp_path, temp_path\n        else:\n            # Handle file path input\n            file_path = Path(source)\n            if not file_path.exists():\n                raise InvalidFileError(f\"File not found: {file_path}\")\n            if not file_path.is_file():\n                raise InvalidFileError(f\"Path is not a file: {file_path}\")\n\n            logger.debug(\"Using existing file: %s\", file_path)\n            return file_path, None\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(source, filename=None, config=None)\n</code></pre> <p>Extract text synchronously from file path or bytes.</p> <p>Parameters:</p> Name Type Description Default <code>Union[Path, str, bytes]</code> <p>File path (Path/str) or file bytes</p> required <code>Optional[str]</code> <p>Required if source is bytes, optional for file paths</p> <code>None</code> <code>Optional[dict]</code> <p>Optional configuration overrides</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filename is missing when source is bytes</p> <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self,\n    source: Union[Path, str, bytes],\n    filename: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file path or bytes.\n\n    Args:\n        source: File path (Path/str) or file bytes\n        filename: Required if source is bytes, optional for file paths\n        config: Optional configuration overrides\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        ValueError: If filename is missing when source is bytes\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    # Get file info for logging\n    file_info = get_file_info(source, filename)\n    logger.debug(\"Processing file: %s\", file_info)\n\n    # Prepare file path (create temp file if needed)\n    file_path, temp_path = self._prepare_file_path(source, filename, config)\n\n    try:\n        # Validate file extension\n        suffix = file_info.extension\n        if not suffix:\n            raise FileTypeNotSupportedError(\n                f\"File has no extension: {file_info.filename}\"\n            )\n\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        # Get handler\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB, temp: %s)\",\n            handler_name,\n            file_info.filename,\n            file_info.size_mb,\n            file_info.is_temp,\n        )\n\n        # Extract text\n        try:\n            result = handler.extract(file_path, config or self.config.__dict__)\n        except Exception as e:\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                file_info.filename,\n                handler_name,\n                e,\n            )\n\n            # Re-raise custom extraction errors\n            if isinstance(e, ExtractionError):\n                raise\n            # Wrap known invalid file errors\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {file_info.filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {file_info.filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            file_info.filename,\n            len(result),\n        )\n        return result\n\n    finally:\n        # Clean up temporary file if created\n        if temp_path:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract(source)","title":"<code>source</code>","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor-functions","title":"Functions","text":""}]}